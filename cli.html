<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>qop.cli API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qop.cli</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle
import subprocess
import logging
from pathlib import Path
from typing import Dict, Union, Optional
from time import sleep
import json

import appdirs
from tqdm import tqdm, trange
from colorama import init, Fore

from qop import config, tasks, scanners, converters
from qop.config import Status, Command, PayloadClass


init()  # init terminal colors
lg = logging.getLogger(__name__)


def handle_missing_args(args, client):
    args.parser.print_help()
    args.parser.exit()


def handle_echo(args, client) -&gt; Dict:
    return client.send_command(Command.QUEUE_PUT, payload=tasks.EchoTask(msg=&#34; &#34;.join(args.msg)))


def handle_re(args, client) -&gt; Dict:

    with open(Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;), &#39;rb&#39;) as f:
        last_args = pickle.load(f)

    if args.destination is not None:
        last_args.paths = args.paths + args.destination
    else:
        last_args.paths = args.sources + [last_args.paths[-1]]

    # global args that should not be overriden
    last_args.verbose = args.verbose
    last_args.log_file = args.log_file
    last_args.log_level = args.log_level

    if last_args.mode == &#34;convert&#34;:
        return handle_convert(last_args, client)
    else:
        return handle_copy_move(last_args, client)


def handle_copy_move(args, client) -&gt; Dict:
    sources = args.paths[:-1]
    dst_dir = args.paths[-1]
    is_queue_active = client.is_queue_active()

    assert isinstance(dst_dir, str)
    assert len(sources) &gt; 0
    assert sources != dst_dir

    # for use by `qop re`
    args_cache = Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;)
    if args_cache.exists():
        args_cache.unlink()
    with open(args_cache, &#39;wb&#39;) as f:
        args.parser = None
        pickle.dump(args, f, pickle.HIGHEST_PROTOCOL)

    if args.include is not None:
        scanner = scanners.ScannerWhitelist(args.include)
        sources = scanner.run(sources)
    elif args.exclude is not None:
        scanner = scanners.ScannerBlacklist(args.exclude)
        sources = scanner.run(sources)

    for source in sources:
        if not isinstance(source, Dict):
            source = {
                &#34;root&#34;: Path(source).resolve().parent,
                &#34;paths&#34;: [Path(source).resolve()]
            }

        for src in source[&#39;paths&#39;]:
            lg.debug(f&#34;inserting {src}&#34;)
            src = Path(src).resolve()
            dst = Path(dst_dir).resolve().joinpath(src.relative_to(source[&#39;root&#39;]))
            if args.mode == &#34;move&#34;:
                tsk = tasks.MoveTask(src=src, dst=dst)
            elif args.mode == &#34;copy&#34;:
                tsk = tasks.CopyTask(src=src, dst=dst)
            else:
                raise ValueError

            rsp = client.send_command(Command.QUEUE_PUT, payload=tsk)

            if not is_queue_active and not args.enqueue_only:
                client.send_command(Command.QUEUE_START)
                is_queue_active = True

            if args.verbose:
                print(format_response(rsp))

            print(format_response_summary(client.stats), end=&#34;\r&#34;)

    if not args.enqueue_only:
        client.send_command(Command.QUEUE_START)
    return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;enqueue finished&#34;}


def handle_convert(args, client) -&gt; Dict:
    sources = args.paths[:-1]
    dst_dir = args.paths[-1]
    is_queue_active = client.is_queue_active()

    assert isinstance(dst_dir, str)
    assert len(sources) &gt; 0
    assert sources != dst_dir

    # cache arguments for use by `qop re`
    args_cache = Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;)
    if args_cache.exists():
        args_cache.unlink()
    with open(args_cache, &#39;wb&#39;) as f:
        args.parser = None
        pickle.dump(args, f, pickle.HIGHEST_PROTOCOL)

    # set up scanner
    if args.include is not None:
        scanner = scanners.ScannerWhitelist(args.include)
    elif args.exclude is not None:
        scanner = scanners.ScannerBlacklist(args.exclude)
    else:
        scanner = scanners.Scanner()

    # setup filetypes to convert
    if args.convert_only is not None:
        conv_mode = &#34;include&#34;
        conv_exts = [&#34;.&#34; + e for e in args.convert_only]
    elif args.convert_not is not None:
        conv_mode = &#34;exclude&#34;
        conv_exts = [&#34;.&#34; + e for e in args.convert_not]
    elif args.convert_none:
        conv_mode = &#34;none&#34;
        conv_exts = None
    else:
        conv_mode = &#34;all&#34;
        conv_exts = None

    conv = converters.Mp3Converter(remove_art=args.remove_art)  # TODO
    conv_copy = converters.CopyConverter(remove_art=args.remove_art)
    sources = scanner.run(sources)

    for source in sources:
        if not isinstance(source, Dict):
            source = {
                &#34;root&#34;: Path(source).resolve().parent,
                &#34;paths&#34;: [Path(source).resolve()]
            }

        for src in source[&#39;paths&#39;]:
            lg.debug(f&#34;inserting {src}&#34;)
            src = Path(src).resolve()
            dst = Path(dst_dir).resolve().joinpath(src.relative_to(source[&#39;root&#39;]))

            # setup convert task
            if conv_mode == &#34;all&#34;:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif conv_mode == &#34;include&#34; and src.suffix in conv_exts:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif conv_mode == &#34;exclude&#34; and src.suffix not in conv_exts:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif args.remove_art:
                tsk = tasks.SimpleConvertTask(src=src, dst=dst, converter=conv_copy)
            else:
                tsk = tasks.CopyTask(src=src, dst=dst)

            rsp = client.send_command(Command.QUEUE_PUT, payload=tsk)

            if not is_queue_active and not args.enqueue_only:
                client.send_command(Command.QUEUE_START)
                is_queue_active = True

            if args.verbose:
                print(format_response(rsp))

            print(format_response_summary(client.stats), end=&#34;\r&#34;)

    if not args.enqueue_only:
        client.send_command(Command.QUEUE_START)
    return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;enqueue finished&#34;}


def handle_daemon_stop(args, client) -&gt; Dict:
    if not client.is_daemon_active():
        return {&#34;status&#34;: Status.SKIP, &#34;msg&#34;: &#34;daemon is not active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}

    return client.send_command(Command.DAEMON_STOP)


def handle_daemon_destroy(args, client) -&gt; Dict:
    client.send_command(Command.QUEUE_FLUSH_ALL)
    return client.send_command(Command.DAEMON_STOP)


def handle_daemon_start(args, client) -&gt; Dict:
    # launch daemon
    if client.is_daemon_active():
        return {&#34;status&#34;: Status.SKIP, &#34;msg&#34;: &#34;daemon is already active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        qop_exc = Path(__file__).resolve().parents[1].joinpath(&#34;qopd.py&#34;)
        assert qop_exc.exists()
        subprocess.Popen([&#34;nohup&#34;, &#34;python3&#34;, qop_exc, &#34;--queue&#34;, &#39;&lt;temp&gt;&#39;], close_fds=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        wait_for_daemon(client, timeout=10)
        return handle_daemon_is_active(args, client)


def handle_daemon_restart(args, client) -&gt; Dict:
    was_active = client.is_daemon_active()
    handle_daemon_stop(args, client)
    wait_for_daemon(client, status=0)
    was_stopped = not client.is_daemon_active()
    handle_daemon_start(args, client)
    wait_for_daemon(client)
    is_active = client.is_daemon_active()

    if is_active:
        if not was_active:
            return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon started&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
        elif not was_stopped:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;daemon is still active but was not restarted&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;:PayloadClass.VALUE}
        else:
            return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon restarted&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        if was_active:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not restart daemon (daemon is offline)&#34;, &#34;payload&#34;: {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}
        else:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not start daemon (daemon is offline)&#34;, &#34;payload&#34;: {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}


def handle_daemon_is_active(args, client):
    if client.is_daemon_active():
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon is active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;no daemon found&#34;, &#34;payload&#34;:  {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}


def handle_simple_command(args, client):
    return client.send_command(args.command)


def handle_queue_progress(args, client):
    facts = client.gather_facts()

    if facts[&#39;tasks.total&#39;] == 0:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;queue is empty&#34;}

    max_processes = facts[&#34;processes.max&#34;]

    with tqdm(total=facts[&#39;tasks.total&#39;], initial=facts[&#39;tasks.total&#39;] - facts[&#39;tasks.pending&#39;]) as pbar:
        bars = [tqdm(bar_format=&#34;{desc}&#34;) for x in range(max_processes + 1)]
        while True:
            sleep(0.1)
            active_tasks = client.active_tasks[&#39;payload&#39;]

            for i in range(len(bars) - 1):
                # keep bar 0 empty so that we get a blank line between the real progress bar and the tasks
                if 0 &lt; i &lt;= len(active_tasks):
                    t = tasks.Task.from_dict(active_tasks[i - 1][&#39;task&#39;]).color_repr()
                    bars[i].desc = t
                    bars[i].update()
                elif i &gt; len(active_tasks):
                    bars[i].desc = config.EL
                    bars[i].update()
            try:
                facts = client.gather_facts()
                pbar.set_description(f&#34;{facts[&#39;processes.active&#39;]} processes&#34;)
                pbar.update(facts[&#39;tasks.total&#39;] - facts[&#39;tasks.pending&#39;] - pbar.n)
            except:
                pass

            if not client.is_daemon_active() or facts[&#39;processes.active&#39;] &lt; 1:
                break

    if facts[&#39;tasks.total&#39;] == facts[&#39;tasks.ok&#39;] + facts[&#39;tasks.skip&#39;]:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;all files transferred successfully&#34;}
    else:
        return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not transfer all files&#34;}


def format_response(rsp) -&gt; str:
    res = color_status(rsp[&#39;status&#39;]) + &#34; &#34;

    try:
        plc = PayloadClass(rsp[&#39;payload_class&#39;])
    except:
        plc = None

    if &#34;payload&#34; in rsp.keys() and rsp[&#39;payload&#39;] is not None:
        payload = rsp[&#39;payload&#39;]
        if plc == PayloadClass.VALUE:
            res = res + str(payload[&#39;value&#39;]) + &#34; &#34;
        elif plc == PayloadClass.TASK:
            res = res + tasks.Task.from_dict(payload).color_repr() + &#34; &#34;
        elif plc == PayloadClass.TASK_LIST:
            res = &#34;\n&#34;.join([tasks.Task.from_dict(x[&#39;task&#39;]).color_repr() for x in payload]) + &#34;\n\n&#34; + res
        else:
            res = res + &#39;\n&#39; + json.dumps(payload, indent=4)

    if &#39;msg&#39; in rsp.keys():
        res = res + f&#34;{Fore.YELLOW}[{rsp[&#39;msg&#39;]}]{Fore.RESET}&#34;

    return res


def format_response_summary(x) -&gt; str:
    total = str(x[&#39;ok&#39;] + x[&#39;skip&#39;] + x[&#39;fail&#39;]).rjust(6, &#34; &#34;)
    ok = Fore.GREEN + str(x[&#39;ok&#39;]).rjust(6, &#34; &#34;) + Fore.RESET
    skip = Fore.BLUE + str(x[&#39;skip&#39;]).rjust(6, &#34; &#34;) + Fore.RESET
    fail = Fore.RED + str(x[&#39;fail&#39;]).rjust(6, &#34; &#34;) + Fore.RESET

    return f&#34;  [enqueue: {total} | ok: {ok} | skip: {skip} | fail: {fail}]&#34;


def color_status(x: int):
    x = Status(x)
    pad = 4
    if x == Status.OK:
        return f&#34;{Fore.GREEN}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;
    elif x == Status.SKIP:
        return f&#34;{Fore.BLUE}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;
    else:
        return f&#34;{Fore.RED}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;


def wait_for_daemon(client, timeout: int = 10, status: int = 1) -&gt; None:
    &#34;&#34;&#34;
    :param client: QopClient
    :type client: QopClient
    :param timeout: Maximum time to wait for the daemon to respond. defaults to 10 seconds.
    :type timeout: int
    :param status: `1`: wait for the daemon to start, `0` wait for the daemon to stop
    :type status: int
    :return: None
    :rtype: None
    &#34;&#34;&#34;
    for i in range(timeout * 10):
        sleep(0.1)

        if status == 1:
            if i &gt; 10:
                print(f&#34;\033[KWaiting for daemon to start (timeout: {timeout - i // 10}s)&#34;, end=&#34;\r&#34;)
            if client.is_daemon_active():
                return None
        elif status == 0:
            if i &gt; 10:
                print(f&#34;\033[KWaiting for daemon to stop (timeout: {timeout - i // 10}s)&#34;, end=&#34;\r&#34;)
            if not client.is_daemon_active():
                return None
        else:
            raise ValueError(&#34;status must be `0` or `1`&#34;)

    raise TimeoutError(&#34;could not connect to daemon&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qop.cli.color_status"><code class="name flex">
<span>def <span class="ident">color_status</span></span>(<span>x: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_status(x: int):
    x = Status(x)
    pad = 4
    if x == Status.OK:
        return f&#34;{Fore.GREEN}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;
    elif x == Status.SKIP:
        return f&#34;{Fore.BLUE}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;
    else:
        return f&#34;{Fore.RED}{x.name.rjust(pad, &#39; &#39;)}{Fore.RESET}&#34;</code></pre>
</details>
</dd>
<dt id="qop.cli.format_response"><code class="name flex">
<span>def <span class="ident">format_response</span></span>(<span>rsp) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_response(rsp) -&gt; str:
    res = color_status(rsp[&#39;status&#39;]) + &#34; &#34;

    try:
        plc = PayloadClass(rsp[&#39;payload_class&#39;])
    except:
        plc = None

    if &#34;payload&#34; in rsp.keys() and rsp[&#39;payload&#39;] is not None:
        payload = rsp[&#39;payload&#39;]
        if plc == PayloadClass.VALUE:
            res = res + str(payload[&#39;value&#39;]) + &#34; &#34;
        elif plc == PayloadClass.TASK:
            res = res + tasks.Task.from_dict(payload).color_repr() + &#34; &#34;
        elif plc == PayloadClass.TASK_LIST:
            res = &#34;\n&#34;.join([tasks.Task.from_dict(x[&#39;task&#39;]).color_repr() for x in payload]) + &#34;\n\n&#34; + res
        else:
            res = res + &#39;\n&#39; + json.dumps(payload, indent=4)

    if &#39;msg&#39; in rsp.keys():
        res = res + f&#34;{Fore.YELLOW}[{rsp[&#39;msg&#39;]}]{Fore.RESET}&#34;

    return res</code></pre>
</details>
</dd>
<dt id="qop.cli.format_response_summary"><code class="name flex">
<span>def <span class="ident">format_response_summary</span></span>(<span>x) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_response_summary(x) -&gt; str:
    total = str(x[&#39;ok&#39;] + x[&#39;skip&#39;] + x[&#39;fail&#39;]).rjust(6, &#34; &#34;)
    ok = Fore.GREEN + str(x[&#39;ok&#39;]).rjust(6, &#34; &#34;) + Fore.RESET
    skip = Fore.BLUE + str(x[&#39;skip&#39;]).rjust(6, &#34; &#34;) + Fore.RESET
    fail = Fore.RED + str(x[&#39;fail&#39;]).rjust(6, &#34; &#34;) + Fore.RESET

    return f&#34;  [enqueue: {total} | ok: {ok} | skip: {skip} | fail: {fail}]&#34;</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_convert"><code class="name flex">
<span>def <span class="ident">handle_convert</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_convert(args, client) -&gt; Dict:
    sources = args.paths[:-1]
    dst_dir = args.paths[-1]
    is_queue_active = client.is_queue_active()

    assert isinstance(dst_dir, str)
    assert len(sources) &gt; 0
    assert sources != dst_dir

    # cache arguments for use by `qop re`
    args_cache = Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;)
    if args_cache.exists():
        args_cache.unlink()
    with open(args_cache, &#39;wb&#39;) as f:
        args.parser = None
        pickle.dump(args, f, pickle.HIGHEST_PROTOCOL)

    # set up scanner
    if args.include is not None:
        scanner = scanners.ScannerWhitelist(args.include)
    elif args.exclude is not None:
        scanner = scanners.ScannerBlacklist(args.exclude)
    else:
        scanner = scanners.Scanner()

    # setup filetypes to convert
    if args.convert_only is not None:
        conv_mode = &#34;include&#34;
        conv_exts = [&#34;.&#34; + e for e in args.convert_only]
    elif args.convert_not is not None:
        conv_mode = &#34;exclude&#34;
        conv_exts = [&#34;.&#34; + e for e in args.convert_not]
    elif args.convert_none:
        conv_mode = &#34;none&#34;
        conv_exts = None
    else:
        conv_mode = &#34;all&#34;
        conv_exts = None

    conv = converters.Mp3Converter(remove_art=args.remove_art)  # TODO
    conv_copy = converters.CopyConverter(remove_art=args.remove_art)
    sources = scanner.run(sources)

    for source in sources:
        if not isinstance(source, Dict):
            source = {
                &#34;root&#34;: Path(source).resolve().parent,
                &#34;paths&#34;: [Path(source).resolve()]
            }

        for src in source[&#39;paths&#39;]:
            lg.debug(f&#34;inserting {src}&#34;)
            src = Path(src).resolve()
            dst = Path(dst_dir).resolve().joinpath(src.relative_to(source[&#39;root&#39;]))

            # setup convert task
            if conv_mode == &#34;all&#34;:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif conv_mode == &#34;include&#34; and src.suffix in conv_exts:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif conv_mode == &#34;exclude&#34; and src.suffix not in conv_exts:
                dst = Path(dst).resolve().with_suffix(&#34;.&#34; + conv.ext)
                tsk = tasks.ConvertTask(src=src, dst=dst, converter=conv)
            elif args.remove_art:
                tsk = tasks.SimpleConvertTask(src=src, dst=dst, converter=conv_copy)
            else:
                tsk = tasks.CopyTask(src=src, dst=dst)

            rsp = client.send_command(Command.QUEUE_PUT, payload=tsk)

            if not is_queue_active and not args.enqueue_only:
                client.send_command(Command.QUEUE_START)
                is_queue_active = True

            if args.verbose:
                print(format_response(rsp))

            print(format_response_summary(client.stats), end=&#34;\r&#34;)

    if not args.enqueue_only:
        client.send_command(Command.QUEUE_START)
    return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;enqueue finished&#34;}</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_copy_move"><code class="name flex">
<span>def <span class="ident">handle_copy_move</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_copy_move(args, client) -&gt; Dict:
    sources = args.paths[:-1]
    dst_dir = args.paths[-1]
    is_queue_active = client.is_queue_active()

    assert isinstance(dst_dir, str)
    assert len(sources) &gt; 0
    assert sources != dst_dir

    # for use by `qop re`
    args_cache = Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;)
    if args_cache.exists():
        args_cache.unlink()
    with open(args_cache, &#39;wb&#39;) as f:
        args.parser = None
        pickle.dump(args, f, pickle.HIGHEST_PROTOCOL)

    if args.include is not None:
        scanner = scanners.ScannerWhitelist(args.include)
        sources = scanner.run(sources)
    elif args.exclude is not None:
        scanner = scanners.ScannerBlacklist(args.exclude)
        sources = scanner.run(sources)

    for source in sources:
        if not isinstance(source, Dict):
            source = {
                &#34;root&#34;: Path(source).resolve().parent,
                &#34;paths&#34;: [Path(source).resolve()]
            }

        for src in source[&#39;paths&#39;]:
            lg.debug(f&#34;inserting {src}&#34;)
            src = Path(src).resolve()
            dst = Path(dst_dir).resolve().joinpath(src.relative_to(source[&#39;root&#39;]))
            if args.mode == &#34;move&#34;:
                tsk = tasks.MoveTask(src=src, dst=dst)
            elif args.mode == &#34;copy&#34;:
                tsk = tasks.CopyTask(src=src, dst=dst)
            else:
                raise ValueError

            rsp = client.send_command(Command.QUEUE_PUT, payload=tsk)

            if not is_queue_active and not args.enqueue_only:
                client.send_command(Command.QUEUE_START)
                is_queue_active = True

            if args.verbose:
                print(format_response(rsp))

            print(format_response_summary(client.stats), end=&#34;\r&#34;)

    if not args.enqueue_only:
        client.send_command(Command.QUEUE_START)
    return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;enqueue finished&#34;}</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_daemon_destroy"><code class="name flex">
<span>def <span class="ident">handle_daemon_destroy</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_daemon_destroy(args, client) -&gt; Dict:
    client.send_command(Command.QUEUE_FLUSH_ALL)
    return client.send_command(Command.DAEMON_STOP)</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_daemon_is_active"><code class="name flex">
<span>def <span class="ident">handle_daemon_is_active</span></span>(<span>args, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_daemon_is_active(args, client):
    if client.is_daemon_active():
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon is active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;no daemon found&#34;, &#34;payload&#34;:  {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_daemon_restart"><code class="name flex">
<span>def <span class="ident">handle_daemon_restart</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_daemon_restart(args, client) -&gt; Dict:
    was_active = client.is_daemon_active()
    handle_daemon_stop(args, client)
    wait_for_daemon(client, status=0)
    was_stopped = not client.is_daemon_active()
    handle_daemon_start(args, client)
    wait_for_daemon(client)
    is_active = client.is_daemon_active()

    if is_active:
        if not was_active:
            return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon started&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
        elif not was_stopped:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;daemon is still active but was not restarted&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;:PayloadClass.VALUE}
        else:
            return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;daemon restarted&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        if was_active:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not restart daemon (daemon is offline)&#34;, &#34;payload&#34;: {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}
        else:
            return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not start daemon (daemon is offline)&#34;, &#34;payload&#34;: {&#34;value&#34;: False}, &#34;payload_class&#34;: PayloadClass.VALUE}</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_daemon_start"><code class="name flex">
<span>def <span class="ident">handle_daemon_start</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_daemon_start(args, client) -&gt; Dict:
    # launch daemon
    if client.is_daemon_active():
        return {&#34;status&#34;: Status.SKIP, &#34;msg&#34;: &#34;daemon is already active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}
    else:
        qop_exc = Path(__file__).resolve().parents[1].joinpath(&#34;qopd.py&#34;)
        assert qop_exc.exists()
        subprocess.Popen([&#34;nohup&#34;, &#34;python3&#34;, qop_exc, &#34;--queue&#34;, &#39;&lt;temp&gt;&#39;], close_fds=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        wait_for_daemon(client, timeout=10)
        return handle_daemon_is_active(args, client)</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_daemon_stop"><code class="name flex">
<span>def <span class="ident">handle_daemon_stop</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_daemon_stop(args, client) -&gt; Dict:
    if not client.is_daemon_active():
        return {&#34;status&#34;: Status.SKIP, &#34;msg&#34;: &#34;daemon is not active&#34;, &#34;payload&#34;: {&#34;value&#34;: True}, &#34;payload_class&#34;: PayloadClass.VALUE}

    return client.send_command(Command.DAEMON_STOP)</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_echo"><code class="name flex">
<span>def <span class="ident">handle_echo</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_echo(args, client) -&gt; Dict:
    return client.send_command(Command.QUEUE_PUT, payload=tasks.EchoTask(msg=&#34; &#34;.join(args.msg)))</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_missing_args"><code class="name flex">
<span>def <span class="ident">handle_missing_args</span></span>(<span>args, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_missing_args(args, client):
    args.parser.print_help()
    args.parser.exit()</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_queue_progress"><code class="name flex">
<span>def <span class="ident">handle_queue_progress</span></span>(<span>args, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_queue_progress(args, client):
    facts = client.gather_facts()

    if facts[&#39;tasks.total&#39;] == 0:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;queue is empty&#34;}

    max_processes = facts[&#34;processes.max&#34;]

    with tqdm(total=facts[&#39;tasks.total&#39;], initial=facts[&#39;tasks.total&#39;] - facts[&#39;tasks.pending&#39;]) as pbar:
        bars = [tqdm(bar_format=&#34;{desc}&#34;) for x in range(max_processes + 1)]
        while True:
            sleep(0.1)
            active_tasks = client.active_tasks[&#39;payload&#39;]

            for i in range(len(bars) - 1):
                # keep bar 0 empty so that we get a blank line between the real progress bar and the tasks
                if 0 &lt; i &lt;= len(active_tasks):
                    t = tasks.Task.from_dict(active_tasks[i - 1][&#39;task&#39;]).color_repr()
                    bars[i].desc = t
                    bars[i].update()
                elif i &gt; len(active_tasks):
                    bars[i].desc = config.EL
                    bars[i].update()
            try:
                facts = client.gather_facts()
                pbar.set_description(f&#34;{facts[&#39;processes.active&#39;]} processes&#34;)
                pbar.update(facts[&#39;tasks.total&#39;] - facts[&#39;tasks.pending&#39;] - pbar.n)
            except:
                pass

            if not client.is_daemon_active() or facts[&#39;processes.active&#39;] &lt; 1:
                break

    if facts[&#39;tasks.total&#39;] == facts[&#39;tasks.ok&#39;] + facts[&#39;tasks.skip&#39;]:
        return {&#34;status&#34;: Status.OK, &#34;msg&#34;: &#34;all files transferred successfully&#34;}
    else:
        return {&#34;status&#34;: Status.FAIL, &#34;msg&#34;: &#34;could not transfer all files&#34;}</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_re"><code class="name flex">
<span>def <span class="ident">handle_re</span></span>(<span>args, client) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_re(args, client) -&gt; Dict:

    with open(Path(appdirs.user_cache_dir(&#39;qop&#39;)).joinpath(&#39;last_args.pickle&#39;), &#39;rb&#39;) as f:
        last_args = pickle.load(f)

    if args.destination is not None:
        last_args.paths = args.paths + args.destination
    else:
        last_args.paths = args.sources + [last_args.paths[-1]]

    # global args that should not be overriden
    last_args.verbose = args.verbose
    last_args.log_file = args.log_file
    last_args.log_level = args.log_level

    if last_args.mode == &#34;convert&#34;:
        return handle_convert(last_args, client)
    else:
        return handle_copy_move(last_args, client)</code></pre>
</details>
</dd>
<dt id="qop.cli.handle_simple_command"><code class="name flex">
<span>def <span class="ident">handle_simple_command</span></span>(<span>args, client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_simple_command(args, client):
    return client.send_command(args.command)</code></pre>
</details>
</dd>
<dt id="qop.cli.wait_for_daemon"><code class="name flex">
<span>def <span class="ident">wait_for_daemon</span></span>(<span>client, timeout: int = 10, status: int = 1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>:param client: QopClient
:type client: QopClient
:param timeout: Maximum time to wait for the daemon to respond. defaults to 10 seconds.
:type timeout: int
:param status: <code>1</code>: wait for the daemon to start, <code>0</code> wait for the daemon to stop
:type status: int
:return: None
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_daemon(client, timeout: int = 10, status: int = 1) -&gt; None:
    &#34;&#34;&#34;
    :param client: QopClient
    :type client: QopClient
    :param timeout: Maximum time to wait for the daemon to respond. defaults to 10 seconds.
    :type timeout: int
    :param status: `1`: wait for the daemon to start, `0` wait for the daemon to stop
    :type status: int
    :return: None
    :rtype: None
    &#34;&#34;&#34;
    for i in range(timeout * 10):
        sleep(0.1)

        if status == 1:
            if i &gt; 10:
                print(f&#34;\033[KWaiting for daemon to start (timeout: {timeout - i // 10}s)&#34;, end=&#34;\r&#34;)
            if client.is_daemon_active():
                return None
        elif status == 0:
            if i &gt; 10:
                print(f&#34;\033[KWaiting for daemon to stop (timeout: {timeout - i // 10}s)&#34;, end=&#34;\r&#34;)
            if not client.is_daemon_active():
                return None
        else:
            raise ValueError(&#34;status must be `0` or `1`&#34;)

    raise TimeoutError(&#34;could not connect to daemon&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qop" href="index.html">qop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qop.cli.color_status" href="#qop.cli.color_status">color_status</a></code></li>
<li><code><a title="qop.cli.format_response" href="#qop.cli.format_response">format_response</a></code></li>
<li><code><a title="qop.cli.format_response_summary" href="#qop.cli.format_response_summary">format_response_summary</a></code></li>
<li><code><a title="qop.cli.handle_convert" href="#qop.cli.handle_convert">handle_convert</a></code></li>
<li><code><a title="qop.cli.handle_copy_move" href="#qop.cli.handle_copy_move">handle_copy_move</a></code></li>
<li><code><a title="qop.cli.handle_daemon_destroy" href="#qop.cli.handle_daemon_destroy">handle_daemon_destroy</a></code></li>
<li><code><a title="qop.cli.handle_daemon_is_active" href="#qop.cli.handle_daemon_is_active">handle_daemon_is_active</a></code></li>
<li><code><a title="qop.cli.handle_daemon_restart" href="#qop.cli.handle_daemon_restart">handle_daemon_restart</a></code></li>
<li><code><a title="qop.cli.handle_daemon_start" href="#qop.cli.handle_daemon_start">handle_daemon_start</a></code></li>
<li><code><a title="qop.cli.handle_daemon_stop" href="#qop.cli.handle_daemon_stop">handle_daemon_stop</a></code></li>
<li><code><a title="qop.cli.handle_echo" href="#qop.cli.handle_echo">handle_echo</a></code></li>
<li><code><a title="qop.cli.handle_missing_args" href="#qop.cli.handle_missing_args">handle_missing_args</a></code></li>
<li><code><a title="qop.cli.handle_queue_progress" href="#qop.cli.handle_queue_progress">handle_queue_progress</a></code></li>
<li><code><a title="qop.cli.handle_re" href="#qop.cli.handle_re">handle_re</a></code></li>
<li><code><a title="qop.cli.handle_simple_command" href="#qop.cli.handle_simple_command">handle_simple_command</a></code></li>
<li><code><a title="qop.cli.wait_for_daemon" href="#qop.cli.wait_for_daemon">wait_for_daemon</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>