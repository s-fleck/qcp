<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>qop.daemon API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qop.daemon</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tempfile
import socket
import logging
import struct
import json
import sys
from typing import Dict, Union, Optional
from pathlib import Path
from time import sleep

from qop import tasks, utils
from qop.exceptions import FileExistsAndShouldBeSkippedError
from qop.config import TaskType, Status, Command, PREHEADER_LEN, PayloadClass


Pathish = Union[Path, str]
lg = logging.getLogger(__name__)


class QopDaemon:
    port = None
    stats = None  # container that implements transfer statistics
    queue = None
    __is_listening = False

    def __init__(
        self,
        port: int = 9393,
        queue_path: Pathish = Path(tempfile.gettempdir()).joinpath(&#34;qop-temp.sqlite3&#34;),
        persist_queue: bool = False
    ):
        &#34;&#34;&#34;
        QopDaemon manages a TaskQueue that stores and executes Tasks (such as file transfer of file convert operations).
        It accepts Commands sent by QopClient.

        :param port: Port to bind the daemon to
        :type port: integer
        :param queue_path: Path for storing the transfer queue
        :type queue_path: Path or str
        :param persist_queue: Whether or not to delete the queue when the daemon is stoped
        :type persist_queue: bool
        &#34;&#34;&#34;
        self.port = port
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # ADDRESS_FAMILY: INTERNET (ip4), tcp
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.new_queue(path=Path(queue_path))
        self.queue.reset_active_tasks()
        self.persist_queue = persist_queue

    def __enter__(self):
        self._socket.bind((&#34;127.0.0.1&#34;, self.port))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.is_listening:
            self.close()

        if not self.persist_queue:
            self.queue.path.unlink()

    def close(self):
        self._socket.shutdown(socket.SHUT_RDWR)
        self._socket.close()
        self.is_listening = False

    def listen(self, port=9393):
        lg = logging.getLogger(__name__)
        self._socket.listen(10)
        self.is_listening = True

        while True:
            client, address = self._socket.accept()
            lg.debug(f&#39;client connected: {address}&#39;)
            req = client.recv(1024)
            lg.debug(f&#34;processing request {req}&#34;)

            if self.queue.is_active():
                if len(self.queue.convert_processes) &lt; self.queue.max_convert_processes:
                    self.queue.run()
                elif len(self.queue.transfer_processes) &lt; self.queue.max_transfer_processes:
                    self.queue.run()
                elif len(self.queue.convert_processes) &gt; self.queue.max_convert_processes:
                    self.queue.stop()
                    self.queue.run()
                elif len(self.queue.transfer_processes) &gt; self.queue.max_transfer_processes:
                    self.queue.stop()
                    self.queue.run()

            if not req:
                continue

            try:
                dd = self.handle_request(req)
                command = dd.body[&#39;command&#39;]

                if command == Command.DAEMON_START:
                    raise NotImplementedError

                elif command == Command.DAEMON_STOP:
                    client.sendall(StatusMessage(Status.OK, &#34;shutting down server&#34;).encode())
                    self.queue.stop()
                    client.close()
                    self.close()
                    break

                elif command == Command.DAEMON_IS_ACTIVE:
                    client.sendall(StatusMessage(Status.OK, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())

                elif command == Command.DAEMON_FACTS:
                    client.sendall(StatusMessage(Status.OK, payload=self.facts(), payload_class=PayloadClass.DAEMON_FACTS).encode())

                elif command == Command.QUEUE_START:
                    self.queue.run(ip=&#34;127.0.0.1&#34;, port=self.port)
                    lg.info(&#34;starting queue&#34;)
                    client.sendall(StatusMessage(Status.OK, &#34;start processing queue&#34;).encode())

                elif command == Command.QUEUE_STOP:
                    if self.queue.active_processes() &gt; 0:
                        self.queue.stop()
                        lg.info(&#34;stopped queue&#34;)
                        client.sendall(StatusMessage(Status.OK, &#34;pause processing queue&#34;).encode())
                    else:
                        lg.info(&#34;cannot stop queue: no queues are active&#34;)
                        client.sendall(StatusMessage(Status.SKIP, &#34;no active queues found&#34;).encode())

                elif command == Command.QUEUE_IS_ACTIVE:
                    if self.queue.active_processes() &gt; 0:
                        client.sendall(StatusMessage(Status.OK, &#34;queue is active&#34;, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())
                    else:
                        client.sendall(StatusMessage(Status.OK, &#34;queue not active&#34;, payload={&#34;value&#34;: False}, payload_class=PayloadClass.VALUE).encode())

                elif command == Command.QUEUE_PROGRESS:
                    client.sendall(StatusMessage(Status.OK, payload=self.queue.progress().to_dict(), payload_class=PayloadClass.QUEUE_PROGRESS).encode())

                elif command == Command.QUEUE_ACTIVE_PROCESSES:
                    client.sendall(StatusMessage(Status.OK, payload={
                        &#34;transfer&#34;:  self.queue.active_processes(type=&#34;transfer&#34;),
                        &#34;convert&#34;: self.queue.active_processes(type=&#34;convert&#34;)
                    }).encode())

                elif command == Command.QUEUE_MAX_PROCESSES:
                    client.sendall(StatusMessage(
                        Status.OK,
                        payload={&#34;value&#34;: self.queue.max_transfer_processes + self.queue.max_convert_processes},
                        payload_class=PayloadClass.VALUE
                    ).encode())

                elif command == Command.QUEUE_FLUSH_ALL:
                    self.queue.flush()
                    client.sendall(StatusMessage(Status.OK, &#34;flushed queue&#34;).encode())

                elif command == Command.QUEUE_FLUSH_PENDING:
                    self.queue.flush(status=Status.PENDING)
                    client.sendall(StatusMessage(Status.OK, &#34;flushed pending tasks from queue&#34;).encode())

                elif command == Command.QUEUE_SHOW:
                    res = self.queue.fetch(status=Status.ACTIVE)
                    client.sendall(StatusMessage(Status.OK, &#34;retrieved active tasks&#34;, payload=res, payload_class=PayloadClass.TASK_LIST).encode())

                elif dd.body[&#39;command&#39;] == Command.QUEUE_PUT:
                    tsk = tasks.Task.from_dict(dd.body[&#39;payload&#39;])
                    try:
                        tsk.__validate__()
                        self.queue.put(tsk)
                        lg.debug(f&#34;enqueued task {tsk}&#34;)
                        client.sendall(StatusMessage(Status.OK, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except FileExistsAndShouldBeSkippedError:
                        msg = f&#34;destination exists&#34;
                        lg.debug(msg)
                        client.sendall(StatusMessage(Status.SKIP, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except FileExistsError:
                        msg = f&#34;destination exists and differs from source&#34;
                        lg.error(msg)
                        client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except:
                        msg = str(sys.exc_info())
                        lg.error(msg)
                        client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                else:
                    msg = f&#34;unknown command {dd.body[&#39;command&#39;]}&#34;
                    lg.error(msg)
                    client.sendall(StatusMessage(Status.FAIL, msg).encode())

            except:
                lg.error(f&#34;unknown error processing request {req}: {sys.exc_info()}&#34;)
                info = sys.exc_info()
                lg.error(info, exc_info=info)
                client.sendall(StatusMessage(Status.FAIL, msg=str(info[0]) + str(info[1])).encode())

    @property
    def is_listening(self) -&gt; bool:
        return self.__is_listening

    @is_listening.setter
    def is_listening(self, x: bool) -&gt; None:
        lg = logging.getLogger(__name__)

        if x:
            lg.info(f&#34;qop-daemon listening on port {self.port}&#34;)
        else:
            lg.debug(&#34;socket closed&#34;)

        self.__is_listening = x

    @staticmethod
    def handle_request(req):
        return RawMessage(req).decode()

    def new_queue(self, path: Path):
        self.queue = tasks.TaskQueue(path=path)

    def facts(self) -&gt; Dict:
        dinfo = {
            &#34;port&#34;: self.port,
            &#34;queue.persist&#34;: self.persist_queue,
        }
        dinfo.update(self.queue.facts())
        return dinfo


class QopClient:
    def __init__(self, ip: str = &#34;127.0.0.1&#34;, port: int = 9393):
        self.ip = ip
        self.port = port
        self.stats = {&#34;ok&#34;: 0, &#34;fail&#34;: 0, &#34;skip&#34;: 0}

    def gather_facts(self, max_tries=10) -&gt; Dict:
        if max_tries == 1:
            res = self.send_command(Command.DAEMON_FACTS)
        else:
            try:
                res = self.send_command(Command.DAEMON_FACTS)
            except:
                sleep(0.1)
                return self.gather_facts(max_tries=max_tries - 1)

        return res[&#39;payload&#39;]

    def get_queue_progress(self, max_tries=10) -&gt; tasks.QueueProgress:  # TODO: deprecated
        if max_tries == 1:
            res = self.send_command(Command.QUEUE_PROGRESS)
        else:
            try:
                res = self.send_command(Command.QUEUE_PROGRESS)
            except:
                sleep(0.1)
                return self.get_queue_progress(max_tries=max_tries - 1)

        return tasks.QueueProgress.from_dict(res[&#39;payload&#39;])

    def is_daemon_active(self) -&gt; bool:
        return utils.is_daemon_active(self.ip, self.port)

    @property
    def max_processes(self) -&gt; list:
        return self.send_command(Command.QUEUE_MAX_PROCESSES)[&#39;payload&#39;][&#39;value&#39;]

    @property
    def active_tasks(self) -&gt; list:
        return self.send_command(Command.QUEUE_SHOW)

    @property
    def active_processes(self) -&gt; int:
        x = self.send_command(Command.QUEUE_ACTIVE_PROCESSES)[&#39;payload&#39;]
        return x[&#39;transfer&#39;] + x[&#39;convert&#39;]

    def is_queue_active(self) -&gt; int:
        x = self.send_command(Command.QUEUE_IS_ACTIVE)[&#39;payload&#39;][&#39;value&#39;]
        return x

    &#34;&#34;&#34;
    Send a CommandMessage to the server

    :param command: Command to send
    :type Command
    :param payload: Optional payload to send along with the command (usually a Task)
    :type None, Dict, Task    
    &#34;&#34;&#34;
    def send_command(self, command: Command, payload: Union[None, Dict, tasks.Task, list] = None) -&gt; Dict:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
            client.connect((self.ip, self.port))
            req = CommandMessage(command, payload=payload)
            client.sendall(req.encode())
            res = RawMessage(client.recv(2048)).decode().body

            # track enqueued tasks of this client
            if command == Command.QUEUE_PUT:
                if res[&#39;status&#39;] == Status.OK:
                    self.stats[&#39;ok&#39;] = self.stats[&#39;ok&#39;] + 1
                if res[&#39;status&#39;] == Status.SKIP:
                    self.stats[&#39;skip&#39;] = self.stats[&#39;skip&#39;] + 1
                if res[&#39;status&#39;] == Status.FAIL:
                    self.stats[&#39;fail&#39;] = self.stats[&#39;fail&#39;] + 1

            return res


class Message:
    &#34;&#34;&#34;Container for requests sent to the qop daemon&#34;&#34;&#34;
    def __init__(
            self,
            body: Dict,
            extra_headers: Optional[Dict] = None
    ) -&gt; None:
        &#34;&#34;&#34;

        :rtype: object
        &#34;&#34;&#34;
        if extra_headers is None:
            extra_headers = {}

        self.body = body
        self.extra_headers = extra_headers

    def encode(self) -&gt; bytes:
        body = bytes(json.dumps(self.body), &#34;utf-8&#34;)

        header = {&#34;content-length&#34;: len(body), &#34;content-type&#34;: &#34;text/json&#34;}
        header.update(self.extra_headers)
        header = bytes(json.dumps(header), &#34;utf-8&#34;)
        header_len: bytes = struct.pack(&#34;!H&#34;, len(header))  # network-endianess, unsigned long integer (4 bytes)

        lg.debug(f&#39;encoding message {body} with header_length={int(struct.unpack(&#34;!H&#34;, header_len)[0])} and content_length={len(body)}&#39;)
        return header_len + header + body

    def __repr__(self) -&gt; str:
        return f&#34;Message: {self.body.__repr__()}&#34;


class RawMessage:
    &#34;&#34;&#34;Container for responses from the qop daemon&#34;&#34;&#34;

    def __init__(self, raw) -&gt; None:
        assert isinstance(raw, bytes)
        self.raw: bytes = raw

    def encode(self) -&gt; bytes:
        return self.raw

    def decode(self) -&gt; Message:
        logging.getLogger(&#34;qop.daemon&#34;).debug(f&#39;decoding message with header_length={self.header_len}&#39;)
        return Message(self.body)

    @property
    def header_len(self) -&gt; int:
        return int(struct.unpack(&#34;!H&#34;, self.raw[:PREHEADER_LEN])[0])

    @property
    def _header(self) -&gt; bytes:
        return self.raw[PREHEADER_LEN:(self.header_len + PREHEADER_LEN)]

    @property
    def header(self) -&gt; Dict:
        header = json.loads(self._header.decode(&#34;utf-8&#34;))
        assert header is not None
        return header

    @property
    def _body(self) -&gt; bytes:
        start = PREHEADER_LEN + self.header_len
        return self.raw[start:start + self.header[&#34;content-length&#34;]]

    @property
    def body(self) -&gt; Dict:
        return json.loads(self._body.decode(&#34;utf-8&#34;))

    def __repr__(self) -&gt; str:
        return f&#34;RawMessage: {self.decode().__repr__()}&#34;


class StatusMessage(Message):
    &#34;&#34;&#34;Messages sent from the daemon to the client to inform it on the status of an operation&#34;&#34;&#34;

    def __init__(self, status: int, msg: Optional[str] = None, payload=None, payload_class=None) -&gt; None:
        &#34;&#34;&#34;
        :param status: Status-code returned from the server (see enums.Status)
        :type status: Status
        :param payload: Optional payload returned by the server. Can be a Dict or an object with a to_dict Method
          (usually a tasks.Task)
        :type payload: Dict, tasks.Task

        :rtype: object
        &#34;&#34;&#34;

        body = {&#34;status&#34;: int(status)}

        if msg is not None:
            body.update({&#34;msg&#34;: msg})

        if payload is not None:
            try:
                payload = payload.to_dict()
            except:
                pass

            body.update({&#34;payload&#34;: payload})

            if payload_class is not None:
                body.update({&#34;payload_class&#34;: payload_class})

        super().__init__(
            body=body,
            extra_headers={&#34;message-class&#34;: &#34;StatusMessage&#34;}
        )
        

class CommandMessage(Message):
    &#34;&#34;&#34;Messages to send commands from the client to the server&#34;&#34;&#34;

    def __init__(self, command: Command, payload=None, payload_class=None) -&gt; None:
        &#34;&#34;&#34;
        :param command: Command-code to send to the server (see enums.Command)
        :type command: Command
        :param payload: Optional payload of the command. This can be a Dict or any Object that has a to_dict() Method.
          Currently the only practical payload is a Task.
        :type payload: tasks.Task, None

        :rtype: object
        &#34;&#34;&#34;

        body = {&#34;command&#34;: int(command)}

        if payload is not None:
            try:
                payload = payload.to_dict()
            except:
                pass

            body.update({&#34;payload&#34;: payload})

            if payload_class is not None:
                body.update({&#34;payload_class&#34;: payload_class})

        super().__init__(
            body=body,
            extra_headers={&#34;message-class&#34;: &#34;CommandMessage&#34;}
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qop.daemon.CommandMessage"><code class="flex name class">
<span>class <span class="ident">CommandMessage</span></span>
<span>(</span><span>command: <a title="qop.config.Command" href="config.html#qop.config.Command">Command</a>, payload=None, payload_class=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Messages to send commands from the client to the server</p>
<p>:param command: Command-code to send to the server (see enums.Command)
:type command: Command
:param payload: Optional payload of the command. This can be a Dict or any Object that has a to_dict() Method.
Currently the only practical payload is a Task.
:type payload: tasks.Task, None</p>
<p>:rtype: object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandMessage(Message):
    &#34;&#34;&#34;Messages to send commands from the client to the server&#34;&#34;&#34;

    def __init__(self, command: Command, payload=None, payload_class=None) -&gt; None:
        &#34;&#34;&#34;
        :param command: Command-code to send to the server (see enums.Command)
        :type command: Command
        :param payload: Optional payload of the command. This can be a Dict or any Object that has a to_dict() Method.
          Currently the only practical payload is a Task.
        :type payload: tasks.Task, None

        :rtype: object
        &#34;&#34;&#34;

        body = {&#34;command&#34;: int(command)}

        if payload is not None:
            try:
                payload = payload.to_dict()
            except:
                pass

            body.update({&#34;payload&#34;: payload})

            if payload_class is not None:
                body.update({&#34;payload_class&#34;: payload_class})

        super().__init__(
            body=body,
            extra_headers={&#34;message-class&#34;: &#34;CommandMessage&#34;}
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.daemon.Message" href="#qop.daemon.Message">Message</a></li>
</ul>
</dd>
<dt id="qop.daemon.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>body: Dict, extra_headers: Union[Dict, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for requests sent to the qop daemon</p>
<p>:rtype: object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message:
    &#34;&#34;&#34;Container for requests sent to the qop daemon&#34;&#34;&#34;
    def __init__(
            self,
            body: Dict,
            extra_headers: Optional[Dict] = None
    ) -&gt; None:
        &#34;&#34;&#34;

        :rtype: object
        &#34;&#34;&#34;
        if extra_headers is None:
            extra_headers = {}

        self.body = body
        self.extra_headers = extra_headers

    def encode(self) -&gt; bytes:
        body = bytes(json.dumps(self.body), &#34;utf-8&#34;)

        header = {&#34;content-length&#34;: len(body), &#34;content-type&#34;: &#34;text/json&#34;}
        header.update(self.extra_headers)
        header = bytes(json.dumps(header), &#34;utf-8&#34;)
        header_len: bytes = struct.pack(&#34;!H&#34;, len(header))  # network-endianess, unsigned long integer (4 bytes)

        lg.debug(f&#39;encoding message {body} with header_length={int(struct.unpack(&#34;!H&#34;, header_len)[0])} and content_length={len(body)}&#39;)
        return header_len + header + body

    def __repr__(self) -&gt; str:
        return f&#34;Message: {self.body.__repr__()}&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qop.daemon.CommandMessage" href="#qop.daemon.CommandMessage">CommandMessage</a></li>
<li><a title="qop.daemon.StatusMessage" href="#qop.daemon.StatusMessage">StatusMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.daemon.Message.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; bytes:
    body = bytes(json.dumps(self.body), &#34;utf-8&#34;)

    header = {&#34;content-length&#34;: len(body), &#34;content-type&#34;: &#34;text/json&#34;}
    header.update(self.extra_headers)
    header = bytes(json.dumps(header), &#34;utf-8&#34;)
    header_len: bytes = struct.pack(&#34;!H&#34;, len(header))  # network-endianess, unsigned long integer (4 bytes)

    lg.debug(f&#39;encoding message {body} with header_length={int(struct.unpack(&#34;!H&#34;, header_len)[0])} and content_length={len(body)}&#39;)
    return header_len + header + body</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.daemon.QopClient"><code class="flex name class">
<span>class <span class="ident">QopClient</span></span>
<span>(</span><span>ip: str = '127.0.0.1', port: int = 9393)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QopClient:
    def __init__(self, ip: str = &#34;127.0.0.1&#34;, port: int = 9393):
        self.ip = ip
        self.port = port
        self.stats = {&#34;ok&#34;: 0, &#34;fail&#34;: 0, &#34;skip&#34;: 0}

    def gather_facts(self, max_tries=10) -&gt; Dict:
        if max_tries == 1:
            res = self.send_command(Command.DAEMON_FACTS)
        else:
            try:
                res = self.send_command(Command.DAEMON_FACTS)
            except:
                sleep(0.1)
                return self.gather_facts(max_tries=max_tries - 1)

        return res[&#39;payload&#39;]

    def get_queue_progress(self, max_tries=10) -&gt; tasks.QueueProgress:  # TODO: deprecated
        if max_tries == 1:
            res = self.send_command(Command.QUEUE_PROGRESS)
        else:
            try:
                res = self.send_command(Command.QUEUE_PROGRESS)
            except:
                sleep(0.1)
                return self.get_queue_progress(max_tries=max_tries - 1)

        return tasks.QueueProgress.from_dict(res[&#39;payload&#39;])

    def is_daemon_active(self) -&gt; bool:
        return utils.is_daemon_active(self.ip, self.port)

    @property
    def max_processes(self) -&gt; list:
        return self.send_command(Command.QUEUE_MAX_PROCESSES)[&#39;payload&#39;][&#39;value&#39;]

    @property
    def active_tasks(self) -&gt; list:
        return self.send_command(Command.QUEUE_SHOW)

    @property
    def active_processes(self) -&gt; int:
        x = self.send_command(Command.QUEUE_ACTIVE_PROCESSES)[&#39;payload&#39;]
        return x[&#39;transfer&#39;] + x[&#39;convert&#39;]

    def is_queue_active(self) -&gt; int:
        x = self.send_command(Command.QUEUE_IS_ACTIVE)[&#39;payload&#39;][&#39;value&#39;]
        return x

    &#34;&#34;&#34;
    Send a CommandMessage to the server

    :param command: Command to send
    :type Command
    :param payload: Optional payload to send along with the command (usually a Task)
    :type None, Dict, Task    
    &#34;&#34;&#34;
    def send_command(self, command: Command, payload: Union[None, Dict, tasks.Task, list] = None) -&gt; Dict:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
            client.connect((self.ip, self.port))
            req = CommandMessage(command, payload=payload)
            client.sendall(req.encode())
            res = RawMessage(client.recv(2048)).decode().body

            # track enqueued tasks of this client
            if command == Command.QUEUE_PUT:
                if res[&#39;status&#39;] == Status.OK:
                    self.stats[&#39;ok&#39;] = self.stats[&#39;ok&#39;] + 1
                if res[&#39;status&#39;] == Status.SKIP:
                    self.stats[&#39;skip&#39;] = self.stats[&#39;skip&#39;] + 1
                if res[&#39;status&#39;] == Status.FAIL:
                    self.stats[&#39;fail&#39;] = self.stats[&#39;fail&#39;] + 1

            return res</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="qop.daemon.QopClient.active_processes"><code class="name">var <span class="ident">active_processes</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_processes(self) -&gt; int:
    x = self.send_command(Command.QUEUE_ACTIVE_PROCESSES)[&#39;payload&#39;]
    return x[&#39;transfer&#39;] + x[&#39;convert&#39;]</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.active_tasks"><code class="name">var <span class="ident">active_tasks</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def active_tasks(self) -&gt; list:
    return self.send_command(Command.QUEUE_SHOW)</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.max_processes"><code class="name">var <span class="ident">max_processes</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_processes(self) -&gt; list:
    return self.send_command(Command.QUEUE_MAX_PROCESSES)[&#39;payload&#39;][&#39;value&#39;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.daemon.QopClient.gather_facts"><code class="name flex">
<span>def <span class="ident">gather_facts</span></span>(<span>self, max_tries=10) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gather_facts(self, max_tries=10) -&gt; Dict:
    if max_tries == 1:
        res = self.send_command(Command.DAEMON_FACTS)
    else:
        try:
            res = self.send_command(Command.DAEMON_FACTS)
        except:
            sleep(0.1)
            return self.gather_facts(max_tries=max_tries - 1)

    return res[&#39;payload&#39;]</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.get_queue_progress"><code class="name flex">
<span>def <span class="ident">get_queue_progress</span></span>(<span>self, max_tries=10) ‑> <a title="qop.tasks.QueueProgress" href="tasks.html#qop.tasks.QueueProgress">QueueProgress</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_queue_progress(self, max_tries=10) -&gt; tasks.QueueProgress:  # TODO: deprecated
    if max_tries == 1:
        res = self.send_command(Command.QUEUE_PROGRESS)
    else:
        try:
            res = self.send_command(Command.QUEUE_PROGRESS)
        except:
            sleep(0.1)
            return self.get_queue_progress(max_tries=max_tries - 1)

    return tasks.QueueProgress.from_dict(res[&#39;payload&#39;])</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.is_daemon_active"><code class="name flex">
<span>def <span class="ident">is_daemon_active</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_daemon_active(self) -&gt; bool:
    return utils.is_daemon_active(self.ip, self.port)</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.is_queue_active"><code class="name flex">
<span>def <span class="ident">is_queue_active</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_queue_active(self) -&gt; int:
    x = self.send_command(Command.QUEUE_IS_ACTIVE)[&#39;payload&#39;][&#39;value&#39;]
    return x</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopClient.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command: <a title="qop.config.Command" href="config.html#qop.config.Command">Command</a>, payload: Union[NoneType, Dict, <a title="qop.tasks.Task" href="tasks.html#qop.tasks.Task">Task</a>, list] = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(self, command: Command, payload: Union[None, Dict, tasks.Task, list] = None) -&gt; Dict:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
        client.connect((self.ip, self.port))
        req = CommandMessage(command, payload=payload)
        client.sendall(req.encode())
        res = RawMessage(client.recv(2048)).decode().body

        # track enqueued tasks of this client
        if command == Command.QUEUE_PUT:
            if res[&#39;status&#39;] == Status.OK:
                self.stats[&#39;ok&#39;] = self.stats[&#39;ok&#39;] + 1
            if res[&#39;status&#39;] == Status.SKIP:
                self.stats[&#39;skip&#39;] = self.stats[&#39;skip&#39;] + 1
            if res[&#39;status&#39;] == Status.FAIL:
                self.stats[&#39;fail&#39;] = self.stats[&#39;fail&#39;] + 1

        return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.daemon.QopDaemon"><code class="flex name class">
<span>class <span class="ident">QopDaemon</span></span>
<span>(</span><span>port: int = 9393, queue_path: Union[pathlib.Path, str] = PosixPath('/tmp/qop-temp.sqlite3'), persist_queue: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>QopDaemon manages a TaskQueue that stores and executes Tasks (such as file transfer of file convert operations).
It accepts Commands sent by QopClient.</p>
<p>:param port: Port to bind the daemon to
:type port: integer
:param queue_path: Path for storing the transfer queue
:type queue_path: Path or str
:param persist_queue: Whether or not to delete the queue when the daemon is stoped
:type persist_queue: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QopDaemon:
    port = None
    stats = None  # container that implements transfer statistics
    queue = None
    __is_listening = False

    def __init__(
        self,
        port: int = 9393,
        queue_path: Pathish = Path(tempfile.gettempdir()).joinpath(&#34;qop-temp.sqlite3&#34;),
        persist_queue: bool = False
    ):
        &#34;&#34;&#34;
        QopDaemon manages a TaskQueue that stores and executes Tasks (such as file transfer of file convert operations).
        It accepts Commands sent by QopClient.

        :param port: Port to bind the daemon to
        :type port: integer
        :param queue_path: Path for storing the transfer queue
        :type queue_path: Path or str
        :param persist_queue: Whether or not to delete the queue when the daemon is stoped
        :type persist_queue: bool
        &#34;&#34;&#34;
        self.port = port
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # ADDRESS_FAMILY: INTERNET (ip4), tcp
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.new_queue(path=Path(queue_path))
        self.queue.reset_active_tasks()
        self.persist_queue = persist_queue

    def __enter__(self):
        self._socket.bind((&#34;127.0.0.1&#34;, self.port))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.is_listening:
            self.close()

        if not self.persist_queue:
            self.queue.path.unlink()

    def close(self):
        self._socket.shutdown(socket.SHUT_RDWR)
        self._socket.close()
        self.is_listening = False

    def listen(self, port=9393):
        lg = logging.getLogger(__name__)
        self._socket.listen(10)
        self.is_listening = True

        while True:
            client, address = self._socket.accept()
            lg.debug(f&#39;client connected: {address}&#39;)
            req = client.recv(1024)
            lg.debug(f&#34;processing request {req}&#34;)

            if self.queue.is_active():
                if len(self.queue.convert_processes) &lt; self.queue.max_convert_processes:
                    self.queue.run()
                elif len(self.queue.transfer_processes) &lt; self.queue.max_transfer_processes:
                    self.queue.run()
                elif len(self.queue.convert_processes) &gt; self.queue.max_convert_processes:
                    self.queue.stop()
                    self.queue.run()
                elif len(self.queue.transfer_processes) &gt; self.queue.max_transfer_processes:
                    self.queue.stop()
                    self.queue.run()

            if not req:
                continue

            try:
                dd = self.handle_request(req)
                command = dd.body[&#39;command&#39;]

                if command == Command.DAEMON_START:
                    raise NotImplementedError

                elif command == Command.DAEMON_STOP:
                    client.sendall(StatusMessage(Status.OK, &#34;shutting down server&#34;).encode())
                    self.queue.stop()
                    client.close()
                    self.close()
                    break

                elif command == Command.DAEMON_IS_ACTIVE:
                    client.sendall(StatusMessage(Status.OK, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())

                elif command == Command.DAEMON_FACTS:
                    client.sendall(StatusMessage(Status.OK, payload=self.facts(), payload_class=PayloadClass.DAEMON_FACTS).encode())

                elif command == Command.QUEUE_START:
                    self.queue.run(ip=&#34;127.0.0.1&#34;, port=self.port)
                    lg.info(&#34;starting queue&#34;)
                    client.sendall(StatusMessage(Status.OK, &#34;start processing queue&#34;).encode())

                elif command == Command.QUEUE_STOP:
                    if self.queue.active_processes() &gt; 0:
                        self.queue.stop()
                        lg.info(&#34;stopped queue&#34;)
                        client.sendall(StatusMessage(Status.OK, &#34;pause processing queue&#34;).encode())
                    else:
                        lg.info(&#34;cannot stop queue: no queues are active&#34;)
                        client.sendall(StatusMessage(Status.SKIP, &#34;no active queues found&#34;).encode())

                elif command == Command.QUEUE_IS_ACTIVE:
                    if self.queue.active_processes() &gt; 0:
                        client.sendall(StatusMessage(Status.OK, &#34;queue is active&#34;, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())
                    else:
                        client.sendall(StatusMessage(Status.OK, &#34;queue not active&#34;, payload={&#34;value&#34;: False}, payload_class=PayloadClass.VALUE).encode())

                elif command == Command.QUEUE_PROGRESS:
                    client.sendall(StatusMessage(Status.OK, payload=self.queue.progress().to_dict(), payload_class=PayloadClass.QUEUE_PROGRESS).encode())

                elif command == Command.QUEUE_ACTIVE_PROCESSES:
                    client.sendall(StatusMessage(Status.OK, payload={
                        &#34;transfer&#34;:  self.queue.active_processes(type=&#34;transfer&#34;),
                        &#34;convert&#34;: self.queue.active_processes(type=&#34;convert&#34;)
                    }).encode())

                elif command == Command.QUEUE_MAX_PROCESSES:
                    client.sendall(StatusMessage(
                        Status.OK,
                        payload={&#34;value&#34;: self.queue.max_transfer_processes + self.queue.max_convert_processes},
                        payload_class=PayloadClass.VALUE
                    ).encode())

                elif command == Command.QUEUE_FLUSH_ALL:
                    self.queue.flush()
                    client.sendall(StatusMessage(Status.OK, &#34;flushed queue&#34;).encode())

                elif command == Command.QUEUE_FLUSH_PENDING:
                    self.queue.flush(status=Status.PENDING)
                    client.sendall(StatusMessage(Status.OK, &#34;flushed pending tasks from queue&#34;).encode())

                elif command == Command.QUEUE_SHOW:
                    res = self.queue.fetch(status=Status.ACTIVE)
                    client.sendall(StatusMessage(Status.OK, &#34;retrieved active tasks&#34;, payload=res, payload_class=PayloadClass.TASK_LIST).encode())

                elif dd.body[&#39;command&#39;] == Command.QUEUE_PUT:
                    tsk = tasks.Task.from_dict(dd.body[&#39;payload&#39;])
                    try:
                        tsk.__validate__()
                        self.queue.put(tsk)
                        lg.debug(f&#34;enqueued task {tsk}&#34;)
                        client.sendall(StatusMessage(Status.OK, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except FileExistsAndShouldBeSkippedError:
                        msg = f&#34;destination exists&#34;
                        lg.debug(msg)
                        client.sendall(StatusMessage(Status.SKIP, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except FileExistsError:
                        msg = f&#34;destination exists and differs from source&#34;
                        lg.error(msg)
                        client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                    except:
                        msg = str(sys.exc_info())
                        lg.error(msg)
                        client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                else:
                    msg = f&#34;unknown command {dd.body[&#39;command&#39;]}&#34;
                    lg.error(msg)
                    client.sendall(StatusMessage(Status.FAIL, msg).encode())

            except:
                lg.error(f&#34;unknown error processing request {req}: {sys.exc_info()}&#34;)
                info = sys.exc_info()
                lg.error(info, exc_info=info)
                client.sendall(StatusMessage(Status.FAIL, msg=str(info[0]) + str(info[1])).encode())

    @property
    def is_listening(self) -&gt; bool:
        return self.__is_listening

    @is_listening.setter
    def is_listening(self, x: bool) -&gt; None:
        lg = logging.getLogger(__name__)

        if x:
            lg.info(f&#34;qop-daemon listening on port {self.port}&#34;)
        else:
            lg.debug(&#34;socket closed&#34;)

        self.__is_listening = x

    @staticmethod
    def handle_request(req):
        return RawMessage(req).decode()

    def new_queue(self, path: Path):
        self.queue = tasks.TaskQueue(path=path)

    def facts(self) -&gt; Dict:
        dinfo = {
            &#34;port&#34;: self.port,
            &#34;queue.persist&#34;: self.persist_queue,
        }
        dinfo.update(self.queue.facts())
        return dinfo</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="qop.daemon.QopDaemon.port"><code class="name">var <span class="ident">port</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.daemon.QopDaemon.queue"><code class="name">var <span class="ident">queue</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.daemon.QopDaemon.stats"><code class="name">var <span class="ident">stats</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="qop.daemon.QopDaemon.handle_request"><code class="name flex">
<span>def <span class="ident">handle_request</span></span>(<span>req)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def handle_request(req):
    return RawMessage(req).decode()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="qop.daemon.QopDaemon.is_listening"><code class="name">var <span class="ident">is_listening</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_listening(self) -&gt; bool:
    return self.__is_listening</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.daemon.QopDaemon.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._socket.shutdown(socket.SHUT_RDWR)
    self._socket.close()
    self.is_listening = False</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopDaemon.facts"><code class="name flex">
<span>def <span class="ident">facts</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def facts(self) -&gt; Dict:
    dinfo = {
        &#34;port&#34;: self.port,
        &#34;queue.persist&#34;: self.persist_queue,
    }
    dinfo.update(self.queue.facts())
    return dinfo</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopDaemon.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self, port=9393)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen(self, port=9393):
    lg = logging.getLogger(__name__)
    self._socket.listen(10)
    self.is_listening = True

    while True:
        client, address = self._socket.accept()
        lg.debug(f&#39;client connected: {address}&#39;)
        req = client.recv(1024)
        lg.debug(f&#34;processing request {req}&#34;)

        if self.queue.is_active():
            if len(self.queue.convert_processes) &lt; self.queue.max_convert_processes:
                self.queue.run()
            elif len(self.queue.transfer_processes) &lt; self.queue.max_transfer_processes:
                self.queue.run()
            elif len(self.queue.convert_processes) &gt; self.queue.max_convert_processes:
                self.queue.stop()
                self.queue.run()
            elif len(self.queue.transfer_processes) &gt; self.queue.max_transfer_processes:
                self.queue.stop()
                self.queue.run()

        if not req:
            continue

        try:
            dd = self.handle_request(req)
            command = dd.body[&#39;command&#39;]

            if command == Command.DAEMON_START:
                raise NotImplementedError

            elif command == Command.DAEMON_STOP:
                client.sendall(StatusMessage(Status.OK, &#34;shutting down server&#34;).encode())
                self.queue.stop()
                client.close()
                self.close()
                break

            elif command == Command.DAEMON_IS_ACTIVE:
                client.sendall(StatusMessage(Status.OK, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())

            elif command == Command.DAEMON_FACTS:
                client.sendall(StatusMessage(Status.OK, payload=self.facts(), payload_class=PayloadClass.DAEMON_FACTS).encode())

            elif command == Command.QUEUE_START:
                self.queue.run(ip=&#34;127.0.0.1&#34;, port=self.port)
                lg.info(&#34;starting queue&#34;)
                client.sendall(StatusMessage(Status.OK, &#34;start processing queue&#34;).encode())

            elif command == Command.QUEUE_STOP:
                if self.queue.active_processes() &gt; 0:
                    self.queue.stop()
                    lg.info(&#34;stopped queue&#34;)
                    client.sendall(StatusMessage(Status.OK, &#34;pause processing queue&#34;).encode())
                else:
                    lg.info(&#34;cannot stop queue: no queues are active&#34;)
                    client.sendall(StatusMessage(Status.SKIP, &#34;no active queues found&#34;).encode())

            elif command == Command.QUEUE_IS_ACTIVE:
                if self.queue.active_processes() &gt; 0:
                    client.sendall(StatusMessage(Status.OK, &#34;queue is active&#34;, payload={&#34;value&#34;: True}, payload_class=PayloadClass.VALUE).encode())
                else:
                    client.sendall(StatusMessage(Status.OK, &#34;queue not active&#34;, payload={&#34;value&#34;: False}, payload_class=PayloadClass.VALUE).encode())

            elif command == Command.QUEUE_PROGRESS:
                client.sendall(StatusMessage(Status.OK, payload=self.queue.progress().to_dict(), payload_class=PayloadClass.QUEUE_PROGRESS).encode())

            elif command == Command.QUEUE_ACTIVE_PROCESSES:
                client.sendall(StatusMessage(Status.OK, payload={
                    &#34;transfer&#34;:  self.queue.active_processes(type=&#34;transfer&#34;),
                    &#34;convert&#34;: self.queue.active_processes(type=&#34;convert&#34;)
                }).encode())

            elif command == Command.QUEUE_MAX_PROCESSES:
                client.sendall(StatusMessage(
                    Status.OK,
                    payload={&#34;value&#34;: self.queue.max_transfer_processes + self.queue.max_convert_processes},
                    payload_class=PayloadClass.VALUE
                ).encode())

            elif command == Command.QUEUE_FLUSH_ALL:
                self.queue.flush()
                client.sendall(StatusMessage(Status.OK, &#34;flushed queue&#34;).encode())

            elif command == Command.QUEUE_FLUSH_PENDING:
                self.queue.flush(status=Status.PENDING)
                client.sendall(StatusMessage(Status.OK, &#34;flushed pending tasks from queue&#34;).encode())

            elif command == Command.QUEUE_SHOW:
                res = self.queue.fetch(status=Status.ACTIVE)
                client.sendall(StatusMessage(Status.OK, &#34;retrieved active tasks&#34;, payload=res, payload_class=PayloadClass.TASK_LIST).encode())

            elif dd.body[&#39;command&#39;] == Command.QUEUE_PUT:
                tsk = tasks.Task.from_dict(dd.body[&#39;payload&#39;])
                try:
                    tsk.__validate__()
                    self.queue.put(tsk)
                    lg.debug(f&#34;enqueued task {tsk}&#34;)
                    client.sendall(StatusMessage(Status.OK, payload=tsk, payload_class=PayloadClass.TASK).encode())
                except FileExistsAndShouldBeSkippedError:
                    msg = f&#34;destination exists&#34;
                    lg.debug(msg)
                    client.sendall(StatusMessage(Status.SKIP, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                except FileExistsError:
                    msg = f&#34;destination exists and differs from source&#34;
                    lg.error(msg)
                    client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
                except:
                    msg = str(sys.exc_info())
                    lg.error(msg)
                    client.sendall(StatusMessage(Status.FAIL, msg=msg, payload=tsk, payload_class=PayloadClass.TASK).encode())
            else:
                msg = f&#34;unknown command {dd.body[&#39;command&#39;]}&#34;
                lg.error(msg)
                client.sendall(StatusMessage(Status.FAIL, msg).encode())

        except:
            lg.error(f&#34;unknown error processing request {req}: {sys.exc_info()}&#34;)
            info = sys.exc_info()
            lg.error(info, exc_info=info)
            client.sendall(StatusMessage(Status.FAIL, msg=str(info[0]) + str(info[1])).encode())</code></pre>
</details>
</dd>
<dt id="qop.daemon.QopDaemon.new_queue"><code class="name flex">
<span>def <span class="ident">new_queue</span></span>(<span>self, path: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_queue(self, path: Path):
    self.queue = tasks.TaskQueue(path=path)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.daemon.RawMessage"><code class="flex name class">
<span>class <span class="ident">RawMessage</span></span>
<span>(</span><span>raw)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for responses from the qop daemon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawMessage:
    &#34;&#34;&#34;Container for responses from the qop daemon&#34;&#34;&#34;

    def __init__(self, raw) -&gt; None:
        assert isinstance(raw, bytes)
        self.raw: bytes = raw

    def encode(self) -&gt; bytes:
        return self.raw

    def decode(self) -&gt; Message:
        logging.getLogger(&#34;qop.daemon&#34;).debug(f&#39;decoding message with header_length={self.header_len}&#39;)
        return Message(self.body)

    @property
    def header_len(self) -&gt; int:
        return int(struct.unpack(&#34;!H&#34;, self.raw[:PREHEADER_LEN])[0])

    @property
    def _header(self) -&gt; bytes:
        return self.raw[PREHEADER_LEN:(self.header_len + PREHEADER_LEN)]

    @property
    def header(self) -&gt; Dict:
        header = json.loads(self._header.decode(&#34;utf-8&#34;))
        assert header is not None
        return header

    @property
    def _body(self) -&gt; bytes:
        start = PREHEADER_LEN + self.header_len
        return self.raw[start:start + self.header[&#34;content-length&#34;]]

    @property
    def body(self) -&gt; Dict:
        return json.loads(self._body.decode(&#34;utf-8&#34;))

    def __repr__(self) -&gt; str:
        return f&#34;RawMessage: {self.decode().__repr__()}&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="qop.daemon.RawMessage.body"><code class="name">var <span class="ident">body</span> : Dict</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def body(self) -&gt; Dict:
    return json.loads(self._body.decode(&#34;utf-8&#34;))</code></pre>
</details>
</dd>
<dt id="qop.daemon.RawMessage.header"><code class="name">var <span class="ident">header</span> : Dict</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; Dict:
    header = json.loads(self._header.decode(&#34;utf-8&#34;))
    assert header is not None
    return header</code></pre>
</details>
</dd>
<dt id="qop.daemon.RawMessage.header_len"><code class="name">var <span class="ident">header_len</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header_len(self) -&gt; int:
    return int(struct.unpack(&#34;!H&#34;, self.raw[:PREHEADER_LEN])[0])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.daemon.RawMessage.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self) ‑> <a title="qop.daemon.Message" href="#qop.daemon.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self) -&gt; Message:
    logging.getLogger(&#34;qop.daemon&#34;).debug(f&#39;decoding message with header_length={self.header_len}&#39;)
    return Message(self.body)</code></pre>
</details>
</dd>
<dt id="qop.daemon.RawMessage.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; bytes:
    return self.raw</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.daemon.StatusMessage"><code class="flex name class">
<span>class <span class="ident">StatusMessage</span></span>
<span>(</span><span>status: int, msg: Union[str, NoneType] = None, payload=None, payload_class=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Messages sent from the daemon to the client to inform it on the status of an operation</p>
<p>:param status: Status-code returned from the server (see enums.Status)
:type status: Status
:param payload: Optional payload returned by the server. Can be a Dict or an object with a to_dict Method
(usually a tasks.Task)
:type payload: Dict, tasks.Task</p>
<p>:rtype: object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatusMessage(Message):
    &#34;&#34;&#34;Messages sent from the daemon to the client to inform it on the status of an operation&#34;&#34;&#34;

    def __init__(self, status: int, msg: Optional[str] = None, payload=None, payload_class=None) -&gt; None:
        &#34;&#34;&#34;
        :param status: Status-code returned from the server (see enums.Status)
        :type status: Status
        :param payload: Optional payload returned by the server. Can be a Dict or an object with a to_dict Method
          (usually a tasks.Task)
        :type payload: Dict, tasks.Task

        :rtype: object
        &#34;&#34;&#34;

        body = {&#34;status&#34;: int(status)}

        if msg is not None:
            body.update({&#34;msg&#34;: msg})

        if payload is not None:
            try:
                payload = payload.to_dict()
            except:
                pass

            body.update({&#34;payload&#34;: payload})

            if payload_class is not None:
                body.update({&#34;payload_class&#34;: payload_class})

        super().__init__(
            body=body,
            extra_headers={&#34;message-class&#34;: &#34;StatusMessage&#34;}
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.daemon.Message" href="#qop.daemon.Message">Message</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qop" href="index.html">qop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qop.daemon.CommandMessage" href="#qop.daemon.CommandMessage">CommandMessage</a></code></h4>
</li>
<li>
<h4><code><a title="qop.daemon.Message" href="#qop.daemon.Message">Message</a></code></h4>
<ul class="">
<li><code><a title="qop.daemon.Message.encode" href="#qop.daemon.Message.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.daemon.QopClient" href="#qop.daemon.QopClient">QopClient</a></code></h4>
<ul class="two-column">
<li><code><a title="qop.daemon.QopClient.active_processes" href="#qop.daemon.QopClient.active_processes">active_processes</a></code></li>
<li><code><a title="qop.daemon.QopClient.active_tasks" href="#qop.daemon.QopClient.active_tasks">active_tasks</a></code></li>
<li><code><a title="qop.daemon.QopClient.gather_facts" href="#qop.daemon.QopClient.gather_facts">gather_facts</a></code></li>
<li><code><a title="qop.daemon.QopClient.get_queue_progress" href="#qop.daemon.QopClient.get_queue_progress">get_queue_progress</a></code></li>
<li><code><a title="qop.daemon.QopClient.is_daemon_active" href="#qop.daemon.QopClient.is_daemon_active">is_daemon_active</a></code></li>
<li><code><a title="qop.daemon.QopClient.is_queue_active" href="#qop.daemon.QopClient.is_queue_active">is_queue_active</a></code></li>
<li><code><a title="qop.daemon.QopClient.max_processes" href="#qop.daemon.QopClient.max_processes">max_processes</a></code></li>
<li><code><a title="qop.daemon.QopClient.send_command" href="#qop.daemon.QopClient.send_command">send_command</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.daemon.QopDaemon" href="#qop.daemon.QopDaemon">QopDaemon</a></code></h4>
<ul class="two-column">
<li><code><a title="qop.daemon.QopDaemon.close" href="#qop.daemon.QopDaemon.close">close</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.facts" href="#qop.daemon.QopDaemon.facts">facts</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.handle_request" href="#qop.daemon.QopDaemon.handle_request">handle_request</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.is_listening" href="#qop.daemon.QopDaemon.is_listening">is_listening</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.listen" href="#qop.daemon.QopDaemon.listen">listen</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.new_queue" href="#qop.daemon.QopDaemon.new_queue">new_queue</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.port" href="#qop.daemon.QopDaemon.port">port</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.queue" href="#qop.daemon.QopDaemon.queue">queue</a></code></li>
<li><code><a title="qop.daemon.QopDaemon.stats" href="#qop.daemon.QopDaemon.stats">stats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.daemon.RawMessage" href="#qop.daemon.RawMessage">RawMessage</a></code></h4>
<ul class="">
<li><code><a title="qop.daemon.RawMessage.body" href="#qop.daemon.RawMessage.body">body</a></code></li>
<li><code><a title="qop.daemon.RawMessage.decode" href="#qop.daemon.RawMessage.decode">decode</a></code></li>
<li><code><a title="qop.daemon.RawMessage.encode" href="#qop.daemon.RawMessage.encode">encode</a></code></li>
<li><code><a title="qop.daemon.RawMessage.header" href="#qop.daemon.RawMessage.header">header</a></code></li>
<li><code><a title="qop.daemon.RawMessage.header_len" href="#qop.daemon.RawMessage.header_len">header_len</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.daemon.StatusMessage" href="#qop.daemon.StatusMessage">StatusMessage</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>