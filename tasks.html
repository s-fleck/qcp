<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>qop.tasks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qop.tasks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import shutil
import os
import json
import sqlite3
import uuid
import filecmp
import multiprocessing
import logging
from pathlib import Path
from typing import Union, Optional, Dict, Tuple, List
from time import sleep

import appdirs
from colorama import init, Fore

from qop.enums import TaskType, Status, Command
from qop.exceptions import AlreadyUnderEvaluationError, FileExistsAndIsIdenticalError, FileExistsAndCannotBeComparedError
from qop import converters, utils


init()
Pathish = Union[Path, str]
lg = logging.getLogger(&#34;qop.tasks&#34;)
CONVERT_CACHE_DIR = Path(appdirs.user_cache_dir(&#34;qop&#34;)).joinpath(&#34;convert_temp&#34;)


class TaskQueue:
    &#34;&#34;&#34;
    A persistent, prioritized queue with multi process support. Use sqlite3 as a storage backend.

    :param transfer_processes: A list of file transfer processes
    :param convert_processes: A list of audio transcode processes
    &#34;&#34;&#34;
    transfer_processes = []
    convert_processes = []

    def __init__(self, path: Pathish, max_transfer_processes=1, max_convert_processes=multiprocessing.cpu_count() - 1) -&gt; None:
        &#34;&#34;&#34;
        Instantiate a TaskQueue

        A TaskQueue is a sqlite3 database with the following columns
        - priority: integer value, the lower the value the earlier the task will be processed
        - task: json representation of the task to execute
        - status: status of the task (ok, running, fail,... see enums.Status)
        - lock: str lock id. NULL except for currently running tasks. usually an uuid

        :param path: Path to store the persistent queue
        :type path: Path or str
        :param max_transfer_processes: maximum number of processes spawned for file transfer operations. Should usually
            be 1.
        :type max_transfer_processes: int
        :param max_convert_processes: maximum number of processes spawned for converting audio files. Defaults to
            `number-of-cpu-cores - 1`.
        :type max_convert_processes: int
        &#34;&#34;&#34;

        if path.exists():
            lg.info(f&#34;using existing queue {path}&#34;)
        else:
            lg.info(f&#34;initializing new queue {path}&#34;)

        self.max_transfer_processes = max_transfer_processes
        self.max_convert_processes = max_convert_processes
        self.con = sqlite3.connect(path, isolation_level=&#34;EXCLUSIVE&#34;, timeout=10)
        self.path = Path(path)

        cur = self.con.cursor()
        cur.execute(&#34;&#34;&#34;
           CREATE TABLE IF NOT EXISTS tasks (
              priority INTEGER NOT NULL,
              task TEXT NOT NULL,
              status INTEGER NOT NULL,
              lock TEXT,
              parent INTEGER,
              UNIQUE(task, status)              
            )              
        &#34;&#34;&#34;)
        self.con.commit()

    @property
    def n_total(self) -&gt; int:
        &#34;&#34;&#34;Count of all tasks in queue (including failed and completed)&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks&#34;).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_pending(self) -&gt; int:
        &#34;&#34;&#34;Number of pending tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.PENDING),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_running(self) -&gt; int:
        &#34;&#34;&#34;Count of currently running tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.RUNNING),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_ok(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.OK),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_fail(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.FAIL),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_skip(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.SKIP),)).fetchall()[0][0]
        cur.close()
        return res

    def progress(self, include_children: bool = False) -&gt; &#34;QueueProgress&#34;:
        cur = self.con.cursor()
        if include_children:
            cur.execute(&#34;SELECT status, COUNT(1) from tasks GROUP BY status&#34;)
        else:
            cur.execute(&#34;SELECT status, COUNT(1) FROM tasks WHERE parent is NULL GROUP BY status&#34;)
        res = cur.fetchall()
        cur.close()

        return QueueProgress.from_list(res)

    def put(self, task: &#34;Task&#34;, priority: int = 10, parent: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Enqueue a task

        :param task: Task to be added to the queue
        :type task: Task
        :param priority: (optional) priority for executing `task` (tasks with lower priority will be executed earlier)
        :type priority: int
        :param parent: (optional) only for child tasks, oid/_ROWID_ of the task that spawned this task
        :type parent: int
        &#34;&#34;&#34;

        lg.debug(f&#34;trying to inserted task {task.to_dict()}&#34;)
        cur = self.con.cursor()
        cur.execute(
            &#34;INSERT OR REPLACE INTO tasks (priority, task, status, parent) VALUES (?, ?, ?, ?)&#34;,
            (priority, task.to_json(), Status.PENDING, parent)
        )

        hammer_commit(self.con)
        lg.debug(f&#34;inserted task {task.to_dict()}&#34;)

    def pop(self, task_type_include: Optional[TaskType] = None, task_type_exclude: Optional[TaskType] = None) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;
        Retrieves Task object and sets status of Task in database to &#34;in progress&#34; (1)

        :raises AlreadyUnderEvaluationError: If trying to pop a tasks that is already being processed  (i.e. if a race
        condition occurs if the queue is processed in parallel)
        &#34;&#34;&#34;
        cur = self.con.cursor()

        assert task_type_include is None or task_type_exclude is None

        if task_type_include is not None:
            cur.execute(
                f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task LIKE &#39;__type___{int(task_type_include)}%&#39; ORDER BY priority LIMIT 1&#34;,
                (Status.PENDING,))
        elif task_type_exclude is not None:
            cur.execute(
                f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task NOT LIKE &#39;__type___{int(task_type_exclude)}%&#39; ORDER BY priority LIMIT 1&#34;,
                (Status.PENDING,))
        else:
            cur.execute(&#34;SELECT _ROWID_ FROM tasks WHERE status = ? ORDER BY priority LIMIT 1&#34;, (Status.PENDING,))

        oid = cur.fetchall()[0][0].__str__()

        # insert a lock UUID into the table so that we can ensure not second thread tries to execute the same
        # task
        lock = uuid.uuid4().hex
        self.set_status(oid, Status.RUNNING, lock)
        cur.execute(&#34;SELECT lock, task FROM tasks WHERE _ROWID_ = ?&#34;, (oid,))
        record = cur.fetchall()[0]
        cur.close()

        if record[0] != lock:
            raise AlreadyUnderEvaluationError

        task = Task.from_dict(json.loads(record[1]))
        lg.debug(f&#34;popped task {task}&#34;)
        task.oid = oid
        return task

    def peek(self) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;
        Retrieves Task object without changing its status in the queue
        &#34;&#34;&#34;
        cur = self.con.cursor()
        cur.execute(&#34;SELECT lock, task from tasks ORDER BY priority LIMIT 1&#34;)
        record = cur.fetchall()[0]
        oid = record[0]

        if oid is not None:
            oid = str(oid)

        task = Task.from_dict(json.loads(record[1]))
        task.oid = oid
        return task

    def print(self, status: Union[Tuple, int, None] = None, n: int = 10) -&gt; None:
        &#34;&#34;&#34;
        Print an overview of the queue

        :param n: number of tasks to fetch
        :type n: int
        :param status: If not None, only fetch Tasks of the given status(es)
        :type status: `int`, `None` or a `tuple` of `int`
        &#34;&#34;&#34;
        assert isinstance(n, int) and (n &gt; 0)
        records = self.fetch(n=n, status=status)
        for record in records:
            print(f&#34;[{record[0]}] {Task.from_dict(json.loads(record[1]))}&#34;)

    def fetch(self, status: Union[Tuple, int, Status, None] = None, n: Optional[int] = None) -&gt; List:
        &#34;&#34;&#34;
        Retrieve the queue

        :param n: number of tasks to fetch
        :type n: int
        :param status: If not None, only fetch Tasks of the given status(es)
        :type status: `int`, `None` or a `tuple` of `int`

        :return a dict containing n queued tasks
        &#34;&#34;&#34;

        if status is not None:
            if isinstance(status, int):
                status = (status,)
            elif isinstance(status, Status):
                status = (int(status),)
            if len(status) &gt; 0:
                status = tuple(int(s) for s in status)
            else:
                raise ValueError(&#34;illegal status&#34;)

            cur = self.con.cursor()
            if n:
                cur.execute(
                    f&#34;SELECT status, task FROM tasks &#34;
                    f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])}) &#34;
                    f&#34;ORDER BY priority LIMIT ?&#34;,
                    status + (n,)
                )
            else:
                cur.execute(
                    f&#34;SELECT status, task FROM tasks &#34;
                    f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])})&#34;
                    &#34;ORDER BY priority&#34;,
                    status
                )
        else:
            cur = self.con.cursor()
            if n:
                cur.execute(&#34;SELECT status, task from tasks ORDER BY priority LIMIT ?&#34;, (str(n),))
            else:
                cur.execute(&#34;SELECT status, task from tasks ORDER BY priority&#34;)

        res = cur.fetchall()
        cur.close()
        res = [{&#34;priority&#34;:x[0], &#34;task&#34;:json.loads(x[1])} for x in res]
        return res

    def reset_running_tasks(self) -&gt; None:
        &#34;&#34;&#34;
        Mark the operation with one status as another status

        :param oid: ID of the task to mark
        :type oid: int
        &#34;&#34;&#34;
        lg.info(f&#34;set all running tasks to pending&#34;)
        cur = self.con.cursor()
        cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where status = ?&#34;, (int(Status.PENDING), int(Status.RUNNING)))
        hammer_commit(self.con)
        cur.close()

    def set_status(self, oid: int, status: Status, lock: str = None) -&gt; None:
        &#34;&#34;&#34;
        Mark the operation with the _ROWID_ `oid` as &#34;pending&#34; (0)

        :param oid: ID of the task to mark
        :type oid: int
        :param status: Status see enums.Status
        :type status: Status
        :param lock: python object-id of the Task that executes the queued task. Must be `None` except for switching
          tasks to *running*.
        :type lock: int
        &#34;&#34;&#34;
        lg.info(f&#34;mark {oid} {status.name}&#34;)
        cur = self.con.cursor()

        if status == Status.RUNNING:
            assert lock is not None
            cur.execute(&#34;UPDATE tasks SET status = ?, lock = ? where _ROWID_ = ?&#34;, (int(status), lock, oid))
        else:
            assert lock is None
            cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where _ROWID_ = ?&#34;, (int(status), oid))

        hammer_commit(self.con)
        cur.close()

    def run(self, ip=None, port=None) -&gt; None:
        &#34;&#34;&#34;Execute all pending tasks&#34;&#34;&#34;

        # remove finished que runs
        self.transfer_processes = [p for p in self.transfer_processes if p.is_alive()]
        self.convert_processes = [p for p in self.convert_processes if p.is_alive()]

        if self.n_pending &lt; 1:
            lg.warning(&#34;queue is empty&#34;)
            return None

        if len(self.transfer_processes) &gt;= self.max_transfer_processes:
            lg.debug(f&#34;already running {self.max_transfer_processes} queues&#34;)

        if len(self.convert_processes) &gt;= self.max_convert_processes:
            lg.debug(f&#34;already running {self.max_convert_processes} convert queues&#34;)

        while len(self.transfer_processes) &lt; self.max_transfer_processes:
            lg.info(&#34;starting new queue runner&#34;)
            p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, None, TaskType.CONVERT))
            p.start()
            self.transfer_processes.append(p)

        while len(self.convert_processes) &lt; self.max_convert_processes:
            lg.info(&#34;starting new convert queue runner&#34;)
            p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, TaskType.CONVERT, None))
            p.start()
            self.convert_processes.append(p)

    def __start_run_process(self, ip=None, port=None, task_type_include=None, task_type_exclude=None) -&gt; None:
        &#34;&#34;&#34;Launch a single process that executes the tasks stored in the queue. This function is called internally
           by self.run() and should not be called directly
        &#34;&#34;&#34;
        progress = self.progress()
        while progress.pending &gt; 0 or progress.running &gt; 0:
            progress = self.progress()

            if ip is not None:
                if utils.is_daemon_active(ip=ip, port=port) is False:
                    lg.fatal(&#34;cannot find daemon thread. stopping queue.&#34;)
                    break
            try:
                op = self.pop(task_type_include=task_type_include, task_type_exclude=task_type_exclude)
            except:
                lg.debug(&#34;waiting for more tasks of correct status&#34;)
                sleep(1)
                continue
            try:
                op.run()
                lg.info(f&#34;task finished: {op}&#34;)
                self.set_status(op.oid, Status.OK)
                try:
                    follow_up = op.spawn()
                    self.put(follow_up, priority=-1, parent=op.oid)
                    lg.info(f&#34;spawned childtask: {follow_up}&#34;)
                except:
                    pass

                if op.parent_oid is not None:
                    self.set_status(op.parent_oid, Status.OK)
                    lg.info(f&#34;parent task finished: {op.parent_oid}&#34;)

            except:
                lg.error(f&#34;task failed: {op}&#34;)
                self.set_status(op.oid, Status.FAIL)
                if op.parent_oid is not None:
                    self.set_status(op.parent_oid, Status.FAIL)
                    lg.info(f&#34;parent task completed: {op.parent_oid}&#34;)

        try:
            shutil.rmtree(CONVERT_CACHE_DIR)
        except:
            pass

        lg.info(&#34;queue is finished&#34;)

    def stop(self) -&gt; None:
        for p in self.convert_processes + self.transfer_processes:
            p.terminate()
        self.reset_running_tasks()

    def is_active(self) -&gt; bool:
        return self.active_processes() &gt; 0

    def active_processes(self, type=None):
        if type is None:
            l = self.transfer_processes + self.convert_processes
        elif type == &#34;transfer&#34;:
            l = self.transfer_processes
        elif type == &#34;convert&#34;:
            l = self.convert_processes
        else:
            raise ValueError

        res = 0
        for p in l:
            if p.is_alive():
                res += 1
        return res

    def flush(self, status: Union[Status, int, None] = None) -&gt; None:
        &#34;&#34;&#34;empty the queue&#34;&#34;&#34;
        cur = self.con.cursor()
        if status is None:
            cur.execute(&#34;DELETE FROM tasks&#34;)
            lg.info(&#34;flushing queue&#34;)
        else:
            cur.execute(&#34;DELETE FROM tasks where status == ?&#34;, (int(status),))
            lg.info(f&#34;flushing tasks with status &#39;{status.name}&#39; from queue&#34;)
        hammer_commit(self.con)
        cur.close()


class Task:
    &#34;&#34;&#34;Abstract class for qop Tasks. Should not be instantiated directly.&#34;&#34;&#34;

    &#34;&#34;&#34;optional rowid of the task in the queue. only for tasks that were retrieved from the queue.&#34;&#34;&#34;
    oid = None
    parent_oid = None

    def __init__(self) -&gt; None:
        self.type = 0

    def run(self) -&gt; None:
        &#34;&#34;&#34;Run a task&#34;&#34;&#34;
        raise NotImplementedError

    @staticmethod
    def from_dict(x: Dict) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;Create a Task of the appropriate subclass from a python dict&#34;&#34;&#34;
        lg.debug(f&#34;parsing task {x}&#34;)
        task_type = x[&#34;type&#34;]

        if task_type == 0:
            return Task()
        elif task_type == TaskType.ECHO:
            return EchoTask(x[&#34;msg&#34;])
        elif task_type == TaskType.FILE:
            return FileTask(x[&#34;src&#34;])
        elif task_type == TaskType.DELETE:
            return DeleteTask(x[&#34;src&#34;])
        elif task_type == TaskType.COPY:
            return CopyTask(x[&#34;src&#34;], x[&#34;dst&#34;])
        elif task_type == TaskType.MOVE:
            return MoveTask(x[&#34;src&#34;], x[&#34;dst&#34;], x[&#39;parent_oid&#39;])
        elif task_type == TaskType.CONVERT_SIMPLE:
            return SimpleConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
        elif task_type == TaskType.CONVERT:
            return ConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
        elif task_type == TaskType.FAIL:
            return FailTask()
        elif task_type == TaskType.SLEEP:
            return SleepTask(x[&#39;seconds&#39;])
        else:
            raise UnknownTaskTypeError

    def __repr__(self) -&gt; str:
        return &#39;NULL&#39;

    def __eq__(self, other) -&gt; bool:
        return self.__dict__ == other.__dict__

    def __ne__(self, other) -&gt; bool:
        return self.__dict__ != other.__dict__

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()

        for el in (&#34;src&#34;, &#34;dst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        return r

    def color_repr(self, color=True):
        self.__repr__()

    def __validate__(self) -&gt; None:
        pass

    def to_json(self):
        return json.dumps(self.to_dict())


class EchoTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self,  msg: str) -&gt; None:
        super().__init__()
        self.msg = msg
        self.type = TaskType.ECHO

    def run(self) -&gt; None:
        print(self.msg)

    def __repr__(self) -&gt; str:
        return f&#39;Echo: &#34;{self.msg}&#34;&#39;

    def color_repr(self, color=True):
        if color:
            op = Fore.YELLOW + &#34;Echo&#34; + Fore.RESET
            msg = Fore.BLUE + self.msg + Fore.RESET
            return f&#39;{op} {msg}&#39;
        else:
            return self.__repr__()


class SleepTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self,  seconds: float) -&gt; None:
        super().__init__()
        self.seconds = seconds
        self.type = TaskType.SLEEP

    def run(self) -&gt; None:
        lg.debug(f&#34;sleeping for {self.seconds} seconds&#34;)
        sleep(self.seconds)
        lg.debug(&#34;woke up&#34;)

    def __repr__(self) -&gt; str:
        return f&#39;Sleep: &#34;{self.seconds}&#34;&#39;

    def color_repr(self, color=True):
        if color:
            op = Fore.YELLOW + &#34;Sleep&#34; + Fore.RESET
            msg = Fore.BLUE + self.seconds + Fore.RESET
            return f&#39;{op} {msg}&#39;
        else:
            return self.__repr__()


class FailTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.msg = &#34;This task always fails&#34;
        self.type = TaskType.FAIL

    def run(self) -&gt; None:
        raise AssertionError

    def __repr__(self) -&gt; str:
        return f&#39;Fail: Always raise an error&#34;&#39;


class FileTask(Task):
    &#34;&#34;&#34;Abstract class for all file-based tasks&#34;&#34;&#34;
    def __init__(self, src: Pathish) -&gt; None:
        super().__init__()
        self.src = Path(src).resolve()
        self.type = None

    def run(self) -&gt; None:
        pass

    def __validate__(self) -&gt; None:
        if not self.src.exists():
            raise FileNotFoundError(f&#39;{self.src} does not exist&#39;)
        elif not (self.src.is_dir() or self.src.is_file()):
            raise TypeError(f&#39;{self.src} is neither a file nor directory&#39;)


class DeleteTask(FileTask):
    &#34;&#34;&#34;Delete a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, validate: bool = True) -&gt; None:
        super().__init__(src=src)
        self.type = TaskType.DELETE

    def run(self) -&gt; None:
        os.unlink(self.src)

    def __repr__(self) -&gt; str:
        return f&#39;DEL {self.src}&#39;


class CopyTask(FileTask):
    &#34;&#34;&#34;Copy a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish) -&gt; None:
        super().__init__(src=src)
        self.dst = Path(dst).resolve()
        self.type = TaskType.COPY

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;COPY&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;COPY {self.src} -&gt; {self.dst}&#39;

    def __validate__(self) -&gt; None:
        super().__validate__()
        if self.dst.exists():
            if filecmp.cmp(self.dst, self.src):
                raise FileExistsAndIsIdenticalError
            else:
                raise FileExistsError

    def run(self) -&gt; None:
        self.__validate__()
        if not self.dst.parent.exists():
            self.dst.parent.mkdir(parents=True)

        if self.src.is_dir():
            shutil.copytree(self.src, self.dst)
        else:
            shutil.copy(self.src, self.dst)


class MoveTask(CopyTask):
    &#34;&#34;&#34;Move a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, parent_oid=None) -&gt; None:
        super().__init__(src=src, dst=dst)
        self.type = TaskType.MOVE
        self.parent_oid = parent_oid

    def run(self) -&gt; None:
        super().__validate__()
        if not self.dst.parent.exists():
            self.dst.parent.mkdir(parents=True)

        if self.src.is_dir():
            shutil.move(self.src, self.dst)
        else:
            shutil.move(self.src, self.dst)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;MOVE&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;MOVE {self.src} -&gt; {self.dst}&#39;


class SimpleConvertTask(CopyTask):
    &#34;&#34;&#34;convert an audio file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, converter: converters.Converter) -&gt; None:
        super().__init__(src=src, dst=dst)
        self.type = TaskType.CONVERT_SIMPLE
        self.converter = converter
        self.src = Path(src).resolve()
        self.dst = Path(dst).resolve()

    def run(self) -&gt; None:
        super().__validate__()
        self.converter.run(self.src, self.dst)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;SCON&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;SCON {self.src} -&gt; {self.dst}&#39;

    def __validate__(self) -&gt; None:
        if not self.src.exists():
            raise FileNotFoundError
        if self.dst.exists():
            raise FileExistsAndCannotBeComparedError

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()
        for el in (&#34;src&#34;, &#34;dst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        r[&#34;converter&#34;] = self.converter.to_dict()
        return r


class ConvertTask(SimpleConvertTask):
    &#34;&#34;&#34;
        ConvertTask transcodes an audio file to a temporary directory and then adds a move task to the queue.
        This makes it possible to cleanly separate transcode and transfer processes.
    &#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, converter: converters.Converter, tempdir=CONVERT_CACHE_DIR) -&gt; None:
        super().__init__(src=src, dst=dst, converter=converter)
        self.type = TaskType.CONVERT
        self.tmpdst = tempdir.joinpath(uuid.uuid4().hex)

    def run(self) -&gt; None:
        super().__validate__()
        lg.debug(f&#34;converting file to temporary destination: {self.tmpdst}&#34;)
        self.converter.run(self.src, self.tmpdst)

    def spawn(self) -&gt; MoveTask:
        # spawn requires that the task was retrieved from the queue and therefore already as an oid that
        # links it to a row in the queue
        assert self.oid is not None
        return MoveTask(self.tmpdst, self.dst, parent_oid=self.oid)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;CONV&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;CONV {self.src} -&gt; {self.dst}&#39;

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()
        for el in (&#34;src&#34;, &#34;dst&#34;, &#34;tmpdst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        r[&#34;converter&#34;] = self.converter.to_dict()
        return r


class TaskQueueElement:
    &#34;&#34;&#34;An enqueued Task&#34;&#34;&#34;

    task = None  #: A Task
    status = None  #: Status of the queued Task
    priority = None  #: Priority of the queued Task

    def __init__(self, task: Task, priority: 1) -&gt; None:
        self.task = task
        self.priority = priority

    def __lt__(self, other) -&gt; bool:
        return self.priority &lt; other.priority

    def __gt__(self, other) -&gt; bool:
        return self.priority &gt; other.priority

    def __eq__(self, other) -&gt; bool:
        return self.__dict__ == other.__dict__

    def __ne__(self, other) -&gt; bool:
        return self.__dict__ != other.__dict__


class QueueProgress:
    &#34;&#34;&#34;Info on the current status of the Queue&#34;&#34;&#34;

    def __init__(self,  pending: int, ok: int, skip: int, fail: int, running: int):
        self.ok = ok
        self.pending = pending
        self.skip = skip
        self.running = running
        self.fail = fail

    @property
    def total(self):
        return self.ok + self.pending + self.skip + self.running + self.fail

    @staticmethod
    def from_dict(x: Dict) -&gt; &#34;QueueProgress&#34;:
        return QueueProgress(
            pending=x[&#39;pending&#39;],
            ok=x[&#39;ok&#39;],
            skip=x[&#39;skip&#39;],
            fail=x[&#39;fail&#39;],
            running=x[&#39;running&#39;]
        )

    @staticmethod
    def from_list(x: List) -&gt; &#34;QueueProgress&#34;:
        &#34;&#34;&#34;Convert a list (for example as returned by an SQL SELECT statement) to a QueueProgress object&#34;&#34;&#34;
        res = {
            &#34;pending&#34;: 0,
            &#34;ok&#34;: 0,
            &#34;skip&#34;: 0,
            &#34;running&#34;: 0,
            &#34;fail&#34;: 0
        }

        for el in x:
            if el[0] == Status.PENDING:
                res.update({&#34;pending&#34;: el[1]})
            elif el[0] == Status.OK:
                res.update({&#34;ok&#34;: el[1]})
            elif el[0] == Status.SKIP:
                res.update({&#34;skip&#34;: el[1]})
            elif el[0] == Status.RUNNING:
                res.update({&#34;running&#34;: el[1]})
            elif el[0] == Status.FAIL:
                res.update({&#34;fail&#34;: el[1]})

        return QueueProgress.from_dict(res)

    def to_dict(self) -&gt; Dict:
        return {
            &#34;total&#34;: self.total,
            &#34;pending&#34;:self.pending,
            &#34;ok&#34;: self.ok,
            &#34;fail&#34;: self.fail,
            &#34;skip&#34;: self.skip,
            &#34;running&#34;: self.running
         }

    def fmt_summary(self):
        return f&#39;  [progress] total {self.total} | pending:  {self.pending} | ok: {self.ok} | fail: {self.fail} | running: {self.running}]&#39;


def hammer_commit(con, max_tries=10):
    if max_tries &lt;= 1:
        con.commit()
    else:
        try:
            con.commit()
        except:
            sleep(0.1)
            hammer_commit(con, max_tries=max_tries - 1)


class UnknownTaskTypeError(ValueError):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qop.tasks.hammer_commit"><code class="name flex">
<span>def <span class="ident">hammer_commit</span></span>(<span>con, max_tries=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hammer_commit(con, max_tries=10):
    if max_tries &lt;= 1:
        con.commit()
    else:
        try:
            con.commit()
        except:
            sleep(0.1)
            hammer_commit(con, max_tries=max_tries - 1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qop.tasks.ConvertTask"><code class="flex name class">
<span>class <span class="ident">ConvertTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str], dst: Union[pathlib.Path, str], converter: <a title="qop.converters.Converter" href="converters.html#qop.converters.Converter">Converter</a>, tempdir=PosixPath('/home/runner/.cache/qop/convert_temp'))</span>
</code></dt>
<dd>
<div class="desc"><p>ConvertTask transcodes an audio file to a temporary directory and then adds a move task to the queue.
This makes it possible to cleanly separate transcode and transfer processes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvertTask(SimpleConvertTask):
    &#34;&#34;&#34;
        ConvertTask transcodes an audio file to a temporary directory and then adds a move task to the queue.
        This makes it possible to cleanly separate transcode and transfer processes.
    &#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, converter: converters.Converter, tempdir=CONVERT_CACHE_DIR) -&gt; None:
        super().__init__(src=src, dst=dst, converter=converter)
        self.type = TaskType.CONVERT
        self.tmpdst = tempdir.joinpath(uuid.uuid4().hex)

    def run(self) -&gt; None:
        super().__validate__()
        lg.debug(f&#34;converting file to temporary destination: {self.tmpdst}&#34;)
        self.converter.run(self.src, self.tmpdst)

    def spawn(self) -&gt; MoveTask:
        # spawn requires that the task was retrieved from the queue and therefore already as an oid that
        # links it to a row in the queue
        assert self.oid is not None
        return MoveTask(self.tmpdst, self.dst, parent_oid=self.oid)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;CONV&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;CONV {self.src} -&gt; {self.dst}&#39;

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()
        for el in (&#34;src&#34;, &#34;dst&#34;, &#34;tmpdst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        r[&#34;converter&#34;] = self.converter.to_dict()
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.SimpleConvertTask" href="#qop.tasks.SimpleConvertTask">SimpleConvertTask</a></li>
<li><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></li>
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.ConvertTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True) -&gt; str:
    if color:
        op = Fore.YELLOW + &#34;CONV&#34; + Fore.RESET
        arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
        src = self.src
        dst = self.dst
        return f&#39;{op} {src} {arrow} {dst}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
<dt id="qop.tasks.ConvertTask.spawn"><code class="name flex">
<span>def <span class="ident">spawn</span></span>(<span>self) ‑> <a title="qop.tasks.MoveTask" href="#qop.tasks.MoveTask">MoveTask</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn(self) -&gt; MoveTask:
    # spawn requires that the task was retrieved from the queue and therefore already as an oid that
    # links it to a row in the queue
    assert self.oid is not None
    return MoveTask(self.tmpdst, self.dst, parent_oid=self.oid)</code></pre>
</details>
</dd>
<dt id="qop.tasks.ConvertTask.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict:
    r = self.__dict__.copy()
    for el in (&#34;src&#34;, &#34;dst&#34;, &#34;tmpdst&#34;):
        if el in r.keys():
            r[el] = str(r[el])
    r[&#34;converter&#34;] = self.converter.to_dict()
    return r</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.SimpleConvertTask" href="#qop.tasks.SimpleConvertTask">SimpleConvertTask</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.SimpleConvertTask.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.SimpleConvertTask.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.CopyTask"><code class="flex name class">
<span>class <span class="ident">CopyTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str], dst: Union[pathlib.Path, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CopyTask(FileTask):
    &#34;&#34;&#34;Copy a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish) -&gt; None:
        super().__init__(src=src)
        self.dst = Path(dst).resolve()
        self.type = TaskType.COPY

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;COPY&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;COPY {self.src} -&gt; {self.dst}&#39;

    def __validate__(self) -&gt; None:
        super().__validate__()
        if self.dst.exists():
            if filecmp.cmp(self.dst, self.src):
                raise FileExistsAndIsIdenticalError
            else:
                raise FileExistsError

    def run(self) -&gt; None:
        self.__validate__()
        if not self.dst.parent.exists():
            self.dst.parent.mkdir(parents=True)

        if self.src.is_dir():
            shutil.copytree(self.src, self.dst)
        else:
            shutil.copy(self.src, self.dst)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qop.tasks.MoveTask" href="#qop.tasks.MoveTask">MoveTask</a></li>
<li><a title="qop.tasks.SimpleConvertTask" href="#qop.tasks.SimpleConvertTask">SimpleConvertTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.CopyTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True) -&gt; str:
    if color:
        op = Fore.YELLOW + &#34;COPY&#34; + Fore.RESET
        arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
        src = self.src
        dst = self.dst
        return f&#39;{op} {src} {arrow} {dst}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.FileTask.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.FileTask.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.DeleteTask"><code class="flex name class">
<span>class <span class="ident">DeleteTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str], validate: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeleteTask(FileTask):
    &#34;&#34;&#34;Delete a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, validate: bool = True) -&gt; None:
        super().__init__(src=src)
        self.type = TaskType.DELETE

    def run(self) -&gt; None:
        os.unlink(self.src)

    def __repr__(self) -&gt; str:
        return f&#39;DEL {self.src}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.FileTask.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.FileTask.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.EchoTask"><code class="flex name class">
<span>class <span class="ident">EchoTask</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Log a message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EchoTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self,  msg: str) -&gt; None:
        super().__init__()
        self.msg = msg
        self.type = TaskType.ECHO

    def run(self) -&gt; None:
        print(self.msg)

    def __repr__(self) -&gt; str:
        return f&#39;Echo: &#34;{self.msg}&#34;&#39;

    def color_repr(self, color=True):
        if color:
            op = Fore.YELLOW + &#34;Echo&#34; + Fore.RESET
            msg = Fore.BLUE + self.msg + Fore.RESET
            return f&#39;{op} {msg}&#39;
        else:
            return self.__repr__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.EchoTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True):
    if color:
        op = Fore.YELLOW + &#34;Echo&#34; + Fore.RESET
        msg = Fore.BLUE + self.msg + Fore.RESET
        return f&#39;{op} {msg}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.Task.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.Task.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.FailTask"><code class="flex name class">
<span>class <span class="ident">FailTask</span></span>
</code></dt>
<dd>
<div class="desc"><p>Log a message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FailTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self) -&gt; None:
        super().__init__()
        self.msg = &#34;This task always fails&#34;
        self.type = TaskType.FAIL

    def run(self) -&gt; None:
        raise AssertionError

    def __repr__(self) -&gt; str:
        return f&#39;Fail: Always raise an error&#34;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.Task.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.Task.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.FileTask"><code class="flex name class">
<span>class <span class="ident">FileTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for all file-based tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileTask(Task):
    &#34;&#34;&#34;Abstract class for all file-based tasks&#34;&#34;&#34;
    def __init__(self, src: Pathish) -&gt; None:
        super().__init__()
        self.src = Path(src).resolve()
        self.type = None

    def run(self) -&gt; None:
        pass

    def __validate__(self) -&gt; None:
        if not self.src.exists():
            raise FileNotFoundError(f&#39;{self.src} does not exist&#39;)
        elif not (self.src.is_dir() or self.src.is_file()):
            raise TypeError(f&#39;{self.src} is neither a file nor directory&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></li>
<li><a title="qop.tasks.DeleteTask" href="#qop.tasks.DeleteTask">DeleteTask</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.Task.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.Task.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.MoveTask"><code class="flex name class">
<span>class <span class="ident">MoveTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str], dst: Union[pathlib.Path, str], parent_oid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move a file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MoveTask(CopyTask):
    &#34;&#34;&#34;Move a file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, parent_oid=None) -&gt; None:
        super().__init__(src=src, dst=dst)
        self.type = TaskType.MOVE
        self.parent_oid = parent_oid

    def run(self) -&gt; None:
        super().__validate__()
        if not self.dst.parent.exists():
            self.dst.parent.mkdir(parents=True)

        if self.src.is_dir():
            shutil.move(self.src, self.dst)
        else:
            shutil.move(self.src, self.dst)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;MOVE&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;MOVE {self.src} -&gt; {self.dst}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></li>
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.MoveTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True) -&gt; str:
    if color:
        op = Fore.YELLOW + &#34;MOVE&#34; + Fore.RESET
        arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
        src = self.src
        dst = self.dst
        return f&#39;{op} {src} {arrow} {dst}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.CopyTask.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.CopyTask.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.QueueProgress"><code class="flex name class">
<span>class <span class="ident">QueueProgress</span></span>
<span>(</span><span>pending: int, ok: int, skip: int, fail: int, running: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Info on the current status of the Queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueueProgress:
    &#34;&#34;&#34;Info on the current status of the Queue&#34;&#34;&#34;

    def __init__(self,  pending: int, ok: int, skip: int, fail: int, running: int):
        self.ok = ok
        self.pending = pending
        self.skip = skip
        self.running = running
        self.fail = fail

    @property
    def total(self):
        return self.ok + self.pending + self.skip + self.running + self.fail

    @staticmethod
    def from_dict(x: Dict) -&gt; &#34;QueueProgress&#34;:
        return QueueProgress(
            pending=x[&#39;pending&#39;],
            ok=x[&#39;ok&#39;],
            skip=x[&#39;skip&#39;],
            fail=x[&#39;fail&#39;],
            running=x[&#39;running&#39;]
        )

    @staticmethod
    def from_list(x: List) -&gt; &#34;QueueProgress&#34;:
        &#34;&#34;&#34;Convert a list (for example as returned by an SQL SELECT statement) to a QueueProgress object&#34;&#34;&#34;
        res = {
            &#34;pending&#34;: 0,
            &#34;ok&#34;: 0,
            &#34;skip&#34;: 0,
            &#34;running&#34;: 0,
            &#34;fail&#34;: 0
        }

        for el in x:
            if el[0] == Status.PENDING:
                res.update({&#34;pending&#34;: el[1]})
            elif el[0] == Status.OK:
                res.update({&#34;ok&#34;: el[1]})
            elif el[0] == Status.SKIP:
                res.update({&#34;skip&#34;: el[1]})
            elif el[0] == Status.RUNNING:
                res.update({&#34;running&#34;: el[1]})
            elif el[0] == Status.FAIL:
                res.update({&#34;fail&#34;: el[1]})

        return QueueProgress.from_dict(res)

    def to_dict(self) -&gt; Dict:
        return {
            &#34;total&#34;: self.total,
            &#34;pending&#34;:self.pending,
            &#34;ok&#34;: self.ok,
            &#34;fail&#34;: self.fail,
            &#34;skip&#34;: self.skip,
            &#34;running&#34;: self.running
         }

    def fmt_summary(self):
        return f&#39;  [progress] total {self.total} | pending:  {self.pending} | ok: {self.ok} | fail: {self.fail} | running: {self.running}]&#39;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="qop.tasks.QueueProgress.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>x: Dict) ‑> <a title="qop.tasks.QueueProgress" href="#qop.tasks.QueueProgress">QueueProgress</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(x: Dict) -&gt; &#34;QueueProgress&#34;:
    return QueueProgress(
        pending=x[&#39;pending&#39;],
        ok=x[&#39;ok&#39;],
        skip=x[&#39;skip&#39;],
        fail=x[&#39;fail&#39;],
        running=x[&#39;running&#39;]
    )</code></pre>
</details>
</dd>
<dt id="qop.tasks.QueueProgress.from_list"><code class="name flex">
<span>def <span class="ident">from_list</span></span>(<span>x: List) ‑> <a title="qop.tasks.QueueProgress" href="#qop.tasks.QueueProgress">QueueProgress</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a list (for example as returned by an SQL SELECT statement) to a QueueProgress object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_list(x: List) -&gt; &#34;QueueProgress&#34;:
    &#34;&#34;&#34;Convert a list (for example as returned by an SQL SELECT statement) to a QueueProgress object&#34;&#34;&#34;
    res = {
        &#34;pending&#34;: 0,
        &#34;ok&#34;: 0,
        &#34;skip&#34;: 0,
        &#34;running&#34;: 0,
        &#34;fail&#34;: 0
    }

    for el in x:
        if el[0] == Status.PENDING:
            res.update({&#34;pending&#34;: el[1]})
        elif el[0] == Status.OK:
            res.update({&#34;ok&#34;: el[1]})
        elif el[0] == Status.SKIP:
            res.update({&#34;skip&#34;: el[1]})
        elif el[0] == Status.RUNNING:
            res.update({&#34;running&#34;: el[1]})
        elif el[0] == Status.FAIL:
            res.update({&#34;fail&#34;: el[1]})

    return QueueProgress.from_dict(res)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="qop.tasks.QueueProgress.total"><code class="name">var <span class="ident">total</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total(self):
    return self.ok + self.pending + self.skip + self.running + self.fail</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.QueueProgress.fmt_summary"><code class="name flex">
<span>def <span class="ident">fmt_summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmt_summary(self):
    return f&#39;  [progress] total {self.total} | pending:  {self.pending} | ok: {self.ok} | fail: {self.fail} | running: {self.running}]&#39;</code></pre>
</details>
</dd>
<dt id="qop.tasks.QueueProgress.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict:
    return {
        &#34;total&#34;: self.total,
        &#34;pending&#34;:self.pending,
        &#34;ok&#34;: self.ok,
        &#34;fail&#34;: self.fail,
        &#34;skip&#34;: self.skip,
        &#34;running&#34;: self.running
     }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.tasks.SimpleConvertTask"><code class="flex name class">
<span>class <span class="ident">SimpleConvertTask</span></span>
<span>(</span><span>src: Union[pathlib.Path, str], dst: Union[pathlib.Path, str], converter: <a title="qop.converters.Converter" href="converters.html#qop.converters.Converter">Converter</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an audio file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleConvertTask(CopyTask):
    &#34;&#34;&#34;convert an audio file&#34;&#34;&#34;
    def __init__(self, src: Pathish, dst: Pathish, converter: converters.Converter) -&gt; None:
        super().__init__(src=src, dst=dst)
        self.type = TaskType.CONVERT_SIMPLE
        self.converter = converter
        self.src = Path(src).resolve()
        self.dst = Path(dst).resolve()

    def run(self) -&gt; None:
        super().__validate__()
        self.converter.run(self.src, self.dst)

    def color_repr(self, color=True) -&gt; str:
        if color:
            op = Fore.YELLOW + &#34;SCON&#34; + Fore.RESET
            arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
            src = self.src
            dst = self.dst
            return f&#39;{op} {src} {arrow} {dst}&#39;
        else:
            return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#39;SCON {self.src} -&gt; {self.dst}&#39;

    def __validate__(self) -&gt; None:
        if not self.src.exists():
            raise FileNotFoundError
        if self.dst.exists():
            raise FileExistsAndCannotBeComparedError

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()
        for el in (&#34;src&#34;, &#34;dst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        r[&#34;converter&#34;] = self.converter.to_dict()
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></li>
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qop.tasks.ConvertTask" href="#qop.tasks.ConvertTask">ConvertTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.SimpleConvertTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True) -&gt; str:
    if color:
        op = Fore.YELLOW + &#34;SCON&#34; + Fore.RESET
        arrow = Fore.YELLOW + &#34;-&gt;&#34; + Fore.RESET
        src = self.src
        dst = self.dst
        return f&#39;{op} {src} {arrow} {dst}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
<dt id="qop.tasks.SimpleConvertTask.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict:
    r = self.__dict__.copy()
    for el in (&#34;src&#34;, &#34;dst&#34;):
        if el in r.keys():
            r[el] = str(r[el])
    r[&#34;converter&#34;] = self.converter.to_dict()
    return r</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.CopyTask.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.CopyTask.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.SleepTask"><code class="flex name class">
<span>class <span class="ident">SleepTask</span></span>
<span>(</span><span>seconds: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Log a message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SleepTask(Task):
    &#34;&#34;&#34;Log a message&#34;&#34;&#34;
    def __init__(self,  seconds: float) -&gt; None:
        super().__init__()
        self.seconds = seconds
        self.type = TaskType.SLEEP

    def run(self) -&gt; None:
        lg.debug(f&#34;sleeping for {self.seconds} seconds&#34;)
        sleep(self.seconds)
        lg.debug(&#34;woke up&#34;)

    def __repr__(self) -&gt; str:
        return f&#39;Sleep: &#34;{self.seconds}&#34;&#39;

    def color_repr(self, color=True):
        if color:
            op = Fore.YELLOW + &#34;Sleep&#34; + Fore.RESET
            msg = Fore.BLUE + self.seconds + Fore.RESET
            return f&#39;{op} {msg}&#39;
        else:
            return self.__repr__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.SleepTask.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True):
    if color:
        op = Fore.YELLOW + &#34;Sleep&#34; + Fore.RESET
        msg = Fore.BLUE + self.seconds + Fore.RESET
        return f&#39;{op} {msg}&#39;
    else:
        return self.__repr__()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></b></code>:
<ul class="hlist">
<li><code><a title="qop.tasks.Task.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.Task.run" href="#qop.tasks.Task.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qop.tasks.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for qop Tasks. Should not be instantiated directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task:
    &#34;&#34;&#34;Abstract class for qop Tasks. Should not be instantiated directly.&#34;&#34;&#34;

    &#34;&#34;&#34;optional rowid of the task in the queue. only for tasks that were retrieved from the queue.&#34;&#34;&#34;
    oid = None
    parent_oid = None

    def __init__(self) -&gt; None:
        self.type = 0

    def run(self) -&gt; None:
        &#34;&#34;&#34;Run a task&#34;&#34;&#34;
        raise NotImplementedError

    @staticmethod
    def from_dict(x: Dict) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;Create a Task of the appropriate subclass from a python dict&#34;&#34;&#34;
        lg.debug(f&#34;parsing task {x}&#34;)
        task_type = x[&#34;type&#34;]

        if task_type == 0:
            return Task()
        elif task_type == TaskType.ECHO:
            return EchoTask(x[&#34;msg&#34;])
        elif task_type == TaskType.FILE:
            return FileTask(x[&#34;src&#34;])
        elif task_type == TaskType.DELETE:
            return DeleteTask(x[&#34;src&#34;])
        elif task_type == TaskType.COPY:
            return CopyTask(x[&#34;src&#34;], x[&#34;dst&#34;])
        elif task_type == TaskType.MOVE:
            return MoveTask(x[&#34;src&#34;], x[&#34;dst&#34;], x[&#39;parent_oid&#39;])
        elif task_type == TaskType.CONVERT_SIMPLE:
            return SimpleConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
        elif task_type == TaskType.CONVERT:
            return ConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
        elif task_type == TaskType.FAIL:
            return FailTask()
        elif task_type == TaskType.SLEEP:
            return SleepTask(x[&#39;seconds&#39;])
        else:
            raise UnknownTaskTypeError

    def __repr__(self) -&gt; str:
        return &#39;NULL&#39;

    def __eq__(self, other) -&gt; bool:
        return self.__dict__ == other.__dict__

    def __ne__(self, other) -&gt; bool:
        return self.__dict__ != other.__dict__

    def to_dict(self) -&gt; Dict:
        r = self.__dict__.copy()

        for el in (&#34;src&#34;, &#34;dst&#34;):
            if el in r.keys():
                r[el] = str(r[el])
        return r

    def color_repr(self, color=True):
        self.__repr__()

    def __validate__(self) -&gt; None:
        pass

    def to_json(self):
        return json.dumps(self.to_dict())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qop.tasks.EchoTask" href="#qop.tasks.EchoTask">EchoTask</a></li>
<li><a title="qop.tasks.FailTask" href="#qop.tasks.FailTask">FailTask</a></li>
<li><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></li>
<li><a title="qop.tasks.SleepTask" href="#qop.tasks.SleepTask">SleepTask</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="qop.tasks.Task.oid"><code class="name">var <span class="ident">oid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.tasks.Task.parent_oid"><code class="name">var <span class="ident">parent_oid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="qop.tasks.Task.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>x: Dict) ‑> <a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a Task of the appropriate subclass from a python dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(x: Dict) -&gt; &#34;Task&#34;:
    &#34;&#34;&#34;Create a Task of the appropriate subclass from a python dict&#34;&#34;&#34;
    lg.debug(f&#34;parsing task {x}&#34;)
    task_type = x[&#34;type&#34;]

    if task_type == 0:
        return Task()
    elif task_type == TaskType.ECHO:
        return EchoTask(x[&#34;msg&#34;])
    elif task_type == TaskType.FILE:
        return FileTask(x[&#34;src&#34;])
    elif task_type == TaskType.DELETE:
        return DeleteTask(x[&#34;src&#34;])
    elif task_type == TaskType.COPY:
        return CopyTask(x[&#34;src&#34;], x[&#34;dst&#34;])
    elif task_type == TaskType.MOVE:
        return MoveTask(x[&#34;src&#34;], x[&#34;dst&#34;], x[&#39;parent_oid&#39;])
    elif task_type == TaskType.CONVERT_SIMPLE:
        return SimpleConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
    elif task_type == TaskType.CONVERT:
        return ConvertTask(x[&#39;src&#39;], x[&#39;dst&#39;], converter=converters.Converter.from_dict(x[&#34;converter&#34;]))
    elif task_type == TaskType.FAIL:
        return FailTask()
    elif task_type == TaskType.SLEEP:
        return SleepTask(x[&#39;seconds&#39;])
    else:
        raise UnknownTaskTypeError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.Task.color_repr"><code class="name flex">
<span>def <span class="ident">color_repr</span></span>(<span>self, color=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_repr(self, color=True):
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="qop.tasks.Task.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Run a task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self) -&gt; None:
    &#34;&#34;&#34;Run a task&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="qop.tasks.Task.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict:
    r = self.__dict__.copy()

    for el in (&#34;src&#34;, &#34;dst&#34;):
        if el in r.keys():
            r[el] = str(r[el])
    return r</code></pre>
</details>
</dd>
<dt id="qop.tasks.Task.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self):
    return json.dumps(self.to_dict())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.tasks.TaskQueue"><code class="flex name class">
<span>class <span class="ident">TaskQueue</span></span>
<span>(</span><span>path: Union[pathlib.Path, str], max_transfer_processes=1, max_convert_processes=1)</span>
</code></dt>
<dd>
<div class="desc"><p>A persistent, prioritized queue with multi process support. Use sqlite3 as a storage backend.</p>
<p>:param transfer_processes: A list of file transfer processes
:param convert_processes: A list of audio transcode processes</p>
<p>Instantiate a TaskQueue</p>
<p>A TaskQueue is a sqlite3 database with the following columns
- priority: integer value, the lower the value the earlier the task will be processed
- task: json representation of the task to execute
- status: status of the task (ok, running, fail,&hellip; see enums.Status)
- lock: str lock id. NULL except for currently running tasks. usually an uuid</p>
<p>:param path: Path to store the persistent queue
:type path: Path or str
:param max_transfer_processes: maximum number of processes spawned for file transfer operations. Should usually
be 1.
:type max_transfer_processes: int
:param max_convert_processes: maximum number of processes spawned for converting audio files. Defaults to
<code>number-of-cpu-cores - 1</code>.
:type max_convert_processes: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskQueue:
    &#34;&#34;&#34;
    A persistent, prioritized queue with multi process support. Use sqlite3 as a storage backend.

    :param transfer_processes: A list of file transfer processes
    :param convert_processes: A list of audio transcode processes
    &#34;&#34;&#34;
    transfer_processes = []
    convert_processes = []

    def __init__(self, path: Pathish, max_transfer_processes=1, max_convert_processes=multiprocessing.cpu_count() - 1) -&gt; None:
        &#34;&#34;&#34;
        Instantiate a TaskQueue

        A TaskQueue is a sqlite3 database with the following columns
        - priority: integer value, the lower the value the earlier the task will be processed
        - task: json representation of the task to execute
        - status: status of the task (ok, running, fail,... see enums.Status)
        - lock: str lock id. NULL except for currently running tasks. usually an uuid

        :param path: Path to store the persistent queue
        :type path: Path or str
        :param max_transfer_processes: maximum number of processes spawned for file transfer operations. Should usually
            be 1.
        :type max_transfer_processes: int
        :param max_convert_processes: maximum number of processes spawned for converting audio files. Defaults to
            `number-of-cpu-cores - 1`.
        :type max_convert_processes: int
        &#34;&#34;&#34;

        if path.exists():
            lg.info(f&#34;using existing queue {path}&#34;)
        else:
            lg.info(f&#34;initializing new queue {path}&#34;)

        self.max_transfer_processes = max_transfer_processes
        self.max_convert_processes = max_convert_processes
        self.con = sqlite3.connect(path, isolation_level=&#34;EXCLUSIVE&#34;, timeout=10)
        self.path = Path(path)

        cur = self.con.cursor()
        cur.execute(&#34;&#34;&#34;
           CREATE TABLE IF NOT EXISTS tasks (
              priority INTEGER NOT NULL,
              task TEXT NOT NULL,
              status INTEGER NOT NULL,
              lock TEXT,
              parent INTEGER,
              UNIQUE(task, status)              
            )              
        &#34;&#34;&#34;)
        self.con.commit()

    @property
    def n_total(self) -&gt; int:
        &#34;&#34;&#34;Count of all tasks in queue (including failed and completed)&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks&#34;).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_pending(self) -&gt; int:
        &#34;&#34;&#34;Number of pending tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.PENDING),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_running(self) -&gt; int:
        &#34;&#34;&#34;Count of currently running tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.RUNNING),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_ok(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.OK),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_fail(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.FAIL),)).fetchall()[0][0]
        cur.close()
        return res

    @property
    def n_skip(self) -&gt; int:
        &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
        cur = self.con.cursor()
        res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.SKIP),)).fetchall()[0][0]
        cur.close()
        return res

    def progress(self, include_children: bool = False) -&gt; &#34;QueueProgress&#34;:
        cur = self.con.cursor()
        if include_children:
            cur.execute(&#34;SELECT status, COUNT(1) from tasks GROUP BY status&#34;)
        else:
            cur.execute(&#34;SELECT status, COUNT(1) FROM tasks WHERE parent is NULL GROUP BY status&#34;)
        res = cur.fetchall()
        cur.close()

        return QueueProgress.from_list(res)

    def put(self, task: &#34;Task&#34;, priority: int = 10, parent: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Enqueue a task

        :param task: Task to be added to the queue
        :type task: Task
        :param priority: (optional) priority for executing `task` (tasks with lower priority will be executed earlier)
        :type priority: int
        :param parent: (optional) only for child tasks, oid/_ROWID_ of the task that spawned this task
        :type parent: int
        &#34;&#34;&#34;

        lg.debug(f&#34;trying to inserted task {task.to_dict()}&#34;)
        cur = self.con.cursor()
        cur.execute(
            &#34;INSERT OR REPLACE INTO tasks (priority, task, status, parent) VALUES (?, ?, ?, ?)&#34;,
            (priority, task.to_json(), Status.PENDING, parent)
        )

        hammer_commit(self.con)
        lg.debug(f&#34;inserted task {task.to_dict()}&#34;)

    def pop(self, task_type_include: Optional[TaskType] = None, task_type_exclude: Optional[TaskType] = None) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;
        Retrieves Task object and sets status of Task in database to &#34;in progress&#34; (1)

        :raises AlreadyUnderEvaluationError: If trying to pop a tasks that is already being processed  (i.e. if a race
        condition occurs if the queue is processed in parallel)
        &#34;&#34;&#34;
        cur = self.con.cursor()

        assert task_type_include is None or task_type_exclude is None

        if task_type_include is not None:
            cur.execute(
                f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task LIKE &#39;__type___{int(task_type_include)}%&#39; ORDER BY priority LIMIT 1&#34;,
                (Status.PENDING,))
        elif task_type_exclude is not None:
            cur.execute(
                f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task NOT LIKE &#39;__type___{int(task_type_exclude)}%&#39; ORDER BY priority LIMIT 1&#34;,
                (Status.PENDING,))
        else:
            cur.execute(&#34;SELECT _ROWID_ FROM tasks WHERE status = ? ORDER BY priority LIMIT 1&#34;, (Status.PENDING,))

        oid = cur.fetchall()[0][0].__str__()

        # insert a lock UUID into the table so that we can ensure not second thread tries to execute the same
        # task
        lock = uuid.uuid4().hex
        self.set_status(oid, Status.RUNNING, lock)
        cur.execute(&#34;SELECT lock, task FROM tasks WHERE _ROWID_ = ?&#34;, (oid,))
        record = cur.fetchall()[0]
        cur.close()

        if record[0] != lock:
            raise AlreadyUnderEvaluationError

        task = Task.from_dict(json.loads(record[1]))
        lg.debug(f&#34;popped task {task}&#34;)
        task.oid = oid
        return task

    def peek(self) -&gt; &#34;Task&#34;:
        &#34;&#34;&#34;
        Retrieves Task object without changing its status in the queue
        &#34;&#34;&#34;
        cur = self.con.cursor()
        cur.execute(&#34;SELECT lock, task from tasks ORDER BY priority LIMIT 1&#34;)
        record = cur.fetchall()[0]
        oid = record[0]

        if oid is not None:
            oid = str(oid)

        task = Task.from_dict(json.loads(record[1]))
        task.oid = oid
        return task

    def print(self, status: Union[Tuple, int, None] = None, n: int = 10) -&gt; None:
        &#34;&#34;&#34;
        Print an overview of the queue

        :param n: number of tasks to fetch
        :type n: int
        :param status: If not None, only fetch Tasks of the given status(es)
        :type status: `int`, `None` or a `tuple` of `int`
        &#34;&#34;&#34;
        assert isinstance(n, int) and (n &gt; 0)
        records = self.fetch(n=n, status=status)
        for record in records:
            print(f&#34;[{record[0]}] {Task.from_dict(json.loads(record[1]))}&#34;)

    def fetch(self, status: Union[Tuple, int, Status, None] = None, n: Optional[int] = None) -&gt; List:
        &#34;&#34;&#34;
        Retrieve the queue

        :param n: number of tasks to fetch
        :type n: int
        :param status: If not None, only fetch Tasks of the given status(es)
        :type status: `int`, `None` or a `tuple` of `int`

        :return a dict containing n queued tasks
        &#34;&#34;&#34;

        if status is not None:
            if isinstance(status, int):
                status = (status,)
            elif isinstance(status, Status):
                status = (int(status),)
            if len(status) &gt; 0:
                status = tuple(int(s) for s in status)
            else:
                raise ValueError(&#34;illegal status&#34;)

            cur = self.con.cursor()
            if n:
                cur.execute(
                    f&#34;SELECT status, task FROM tasks &#34;
                    f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])}) &#34;
                    f&#34;ORDER BY priority LIMIT ?&#34;,
                    status + (n,)
                )
            else:
                cur.execute(
                    f&#34;SELECT status, task FROM tasks &#34;
                    f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])})&#34;
                    &#34;ORDER BY priority&#34;,
                    status
                )
        else:
            cur = self.con.cursor()
            if n:
                cur.execute(&#34;SELECT status, task from tasks ORDER BY priority LIMIT ?&#34;, (str(n),))
            else:
                cur.execute(&#34;SELECT status, task from tasks ORDER BY priority&#34;)

        res = cur.fetchall()
        cur.close()
        res = [{&#34;priority&#34;:x[0], &#34;task&#34;:json.loads(x[1])} for x in res]
        return res

    def reset_running_tasks(self) -&gt; None:
        &#34;&#34;&#34;
        Mark the operation with one status as another status

        :param oid: ID of the task to mark
        :type oid: int
        &#34;&#34;&#34;
        lg.info(f&#34;set all running tasks to pending&#34;)
        cur = self.con.cursor()
        cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where status = ?&#34;, (int(Status.PENDING), int(Status.RUNNING)))
        hammer_commit(self.con)
        cur.close()

    def set_status(self, oid: int, status: Status, lock: str = None) -&gt; None:
        &#34;&#34;&#34;
        Mark the operation with the _ROWID_ `oid` as &#34;pending&#34; (0)

        :param oid: ID of the task to mark
        :type oid: int
        :param status: Status see enums.Status
        :type status: Status
        :param lock: python object-id of the Task that executes the queued task. Must be `None` except for switching
          tasks to *running*.
        :type lock: int
        &#34;&#34;&#34;
        lg.info(f&#34;mark {oid} {status.name}&#34;)
        cur = self.con.cursor()

        if status == Status.RUNNING:
            assert lock is not None
            cur.execute(&#34;UPDATE tasks SET status = ?, lock = ? where _ROWID_ = ?&#34;, (int(status), lock, oid))
        else:
            assert lock is None
            cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where _ROWID_ = ?&#34;, (int(status), oid))

        hammer_commit(self.con)
        cur.close()

    def run(self, ip=None, port=None) -&gt; None:
        &#34;&#34;&#34;Execute all pending tasks&#34;&#34;&#34;

        # remove finished que runs
        self.transfer_processes = [p for p in self.transfer_processes if p.is_alive()]
        self.convert_processes = [p for p in self.convert_processes if p.is_alive()]

        if self.n_pending &lt; 1:
            lg.warning(&#34;queue is empty&#34;)
            return None

        if len(self.transfer_processes) &gt;= self.max_transfer_processes:
            lg.debug(f&#34;already running {self.max_transfer_processes} queues&#34;)

        if len(self.convert_processes) &gt;= self.max_convert_processes:
            lg.debug(f&#34;already running {self.max_convert_processes} convert queues&#34;)

        while len(self.transfer_processes) &lt; self.max_transfer_processes:
            lg.info(&#34;starting new queue runner&#34;)
            p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, None, TaskType.CONVERT))
            p.start()
            self.transfer_processes.append(p)

        while len(self.convert_processes) &lt; self.max_convert_processes:
            lg.info(&#34;starting new convert queue runner&#34;)
            p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, TaskType.CONVERT, None))
            p.start()
            self.convert_processes.append(p)

    def __start_run_process(self, ip=None, port=None, task_type_include=None, task_type_exclude=None) -&gt; None:
        &#34;&#34;&#34;Launch a single process that executes the tasks stored in the queue. This function is called internally
           by self.run() and should not be called directly
        &#34;&#34;&#34;
        progress = self.progress()
        while progress.pending &gt; 0 or progress.running &gt; 0:
            progress = self.progress()

            if ip is not None:
                if utils.is_daemon_active(ip=ip, port=port) is False:
                    lg.fatal(&#34;cannot find daemon thread. stopping queue.&#34;)
                    break
            try:
                op = self.pop(task_type_include=task_type_include, task_type_exclude=task_type_exclude)
            except:
                lg.debug(&#34;waiting for more tasks of correct status&#34;)
                sleep(1)
                continue
            try:
                op.run()
                lg.info(f&#34;task finished: {op}&#34;)
                self.set_status(op.oid, Status.OK)
                try:
                    follow_up = op.spawn()
                    self.put(follow_up, priority=-1, parent=op.oid)
                    lg.info(f&#34;spawned childtask: {follow_up}&#34;)
                except:
                    pass

                if op.parent_oid is not None:
                    self.set_status(op.parent_oid, Status.OK)
                    lg.info(f&#34;parent task finished: {op.parent_oid}&#34;)

            except:
                lg.error(f&#34;task failed: {op}&#34;)
                self.set_status(op.oid, Status.FAIL)
                if op.parent_oid is not None:
                    self.set_status(op.parent_oid, Status.FAIL)
                    lg.info(f&#34;parent task completed: {op.parent_oid}&#34;)

        try:
            shutil.rmtree(CONVERT_CACHE_DIR)
        except:
            pass

        lg.info(&#34;queue is finished&#34;)

    def stop(self) -&gt; None:
        for p in self.convert_processes + self.transfer_processes:
            p.terminate()
        self.reset_running_tasks()

    def is_active(self) -&gt; bool:
        return self.active_processes() &gt; 0

    def active_processes(self, type=None):
        if type is None:
            l = self.transfer_processes + self.convert_processes
        elif type == &#34;transfer&#34;:
            l = self.transfer_processes
        elif type == &#34;convert&#34;:
            l = self.convert_processes
        else:
            raise ValueError

        res = 0
        for p in l:
            if p.is_alive():
                res += 1
        return res

    def flush(self, status: Union[Status, int, None] = None) -&gt; None:
        &#34;&#34;&#34;empty the queue&#34;&#34;&#34;
        cur = self.con.cursor()
        if status is None:
            cur.execute(&#34;DELETE FROM tasks&#34;)
            lg.info(&#34;flushing queue&#34;)
        else:
            cur.execute(&#34;DELETE FROM tasks where status == ?&#34;, (int(status),))
            lg.info(f&#34;flushing tasks with status &#39;{status.name}&#39; from queue&#34;)
        hammer_commit(self.con)
        cur.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="qop.tasks.TaskQueue.convert_processes"><code class="name">var <span class="ident">convert_processes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.tasks.TaskQueue.transfer_processes"><code class="name">var <span class="ident">transfer_processes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="qop.tasks.TaskQueue.n_fail"><code class="name">var <span class="ident">n_fail</span> : int</code></dt>
<dd>
<div class="desc"><p>count of completed tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_fail(self) -&gt; int:
    &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.FAIL),)).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.n_ok"><code class="name">var <span class="ident">n_ok</span> : int</code></dt>
<dd>
<div class="desc"><p>count of completed tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_ok(self) -&gt; int:
    &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.OK),)).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.n_pending"><code class="name">var <span class="ident">n_pending</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of pending tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_pending(self) -&gt; int:
    &#34;&#34;&#34;Number of pending tasks&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.PENDING),)).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.n_running"><code class="name">var <span class="ident">n_running</span> : int</code></dt>
<dd>
<div class="desc"><p>Count of currently running tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_running(self) -&gt; int:
    &#34;&#34;&#34;Count of currently running tasks&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) FROM tasks WHERE status = ?&#34;, (int(Status.RUNNING),)).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.n_skip"><code class="name">var <span class="ident">n_skip</span> : int</code></dt>
<dd>
<div class="desc"><p>count of completed tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_skip(self) -&gt; int:
    &#34;&#34;&#34;count of completed tasks&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) from tasks WHERE status = ?&#34;, (int(Status.SKIP),)).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.n_total"><code class="name">var <span class="ident">n_total</span> : int</code></dt>
<dd>
<div class="desc"><p>Count of all tasks in queue (including failed and completed)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_total(self) -&gt; int:
    &#34;&#34;&#34;Count of all tasks in queue (including failed and completed)&#34;&#34;&#34;
    cur = self.con.cursor()
    res = cur.execute(&#34;SELECT COUNT(1) from tasks&#34;).fetchall()[0][0]
    cur.close()
    return res</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="qop.tasks.TaskQueue.active_processes"><code class="name flex">
<span>def <span class="ident">active_processes</span></span>(<span>self, type=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def active_processes(self, type=None):
    if type is None:
        l = self.transfer_processes + self.convert_processes
    elif type == &#34;transfer&#34;:
        l = self.transfer_processes
    elif type == &#34;convert&#34;:
        l = self.convert_processes
    else:
        raise ValueError

    res = 0
    for p in l:
        if p.is_alive():
            res += 1
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, status: Union[Tuple, int, <a title="qop.enums.Status" href="enums.html#qop.enums.Status">Status</a>, NoneType] = None, n: Union[int, NoneType] = None) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the queue</p>
<p>:param n: number of tasks to fetch
:type n: int
:param status: If not None, only fetch Tasks of the given status(es)
:type status: <code>int</code>, <code>None</code> or a <code>tuple</code> of <code>int</code></p>
<p>:return a dict containing n queued tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self, status: Union[Tuple, int, Status, None] = None, n: Optional[int] = None) -&gt; List:
    &#34;&#34;&#34;
    Retrieve the queue

    :param n: number of tasks to fetch
    :type n: int
    :param status: If not None, only fetch Tasks of the given status(es)
    :type status: `int`, `None` or a `tuple` of `int`

    :return a dict containing n queued tasks
    &#34;&#34;&#34;

    if status is not None:
        if isinstance(status, int):
            status = (status,)
        elif isinstance(status, Status):
            status = (int(status),)
        if len(status) &gt; 0:
            status = tuple(int(s) for s in status)
        else:
            raise ValueError(&#34;illegal status&#34;)

        cur = self.con.cursor()
        if n:
            cur.execute(
                f&#34;SELECT status, task FROM tasks &#34;
                f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])}) &#34;
                f&#34;ORDER BY priority LIMIT ?&#34;,
                status + (n,)
            )
        else:
            cur.execute(
                f&#34;SELECT status, task FROM tasks &#34;
                f&#34;WHERE status IN ({&#39;,&#39;.join([&#39;?&#39; for x in status])})&#34;
                &#34;ORDER BY priority&#34;,
                status
            )
    else:
        cur = self.con.cursor()
        if n:
            cur.execute(&#34;SELECT status, task from tasks ORDER BY priority LIMIT ?&#34;, (str(n),))
        else:
            cur.execute(&#34;SELECT status, task from tasks ORDER BY priority&#34;)

    res = cur.fetchall()
    cur.close()
    res = [{&#34;priority&#34;:x[0], &#34;task&#34;:json.loads(x[1])} for x in res]
    return res</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self, status: Union[<a title="qop.enums.Status" href="enums.html#qop.enums.Status">Status</a>, int, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>empty the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self, status: Union[Status, int, None] = None) -&gt; None:
    &#34;&#34;&#34;empty the queue&#34;&#34;&#34;
    cur = self.con.cursor()
    if status is None:
        cur.execute(&#34;DELETE FROM tasks&#34;)
        lg.info(&#34;flushing queue&#34;)
    else:
        cur.execute(&#34;DELETE FROM tasks where status == ?&#34;, (int(status),))
        lg.info(f&#34;flushing tasks with status &#39;{status.name}&#39; from queue&#34;)
    hammer_commit(self.con)
    cur.close()</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.is_active"><code class="name flex">
<span>def <span class="ident">is_active</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_active(self) -&gt; bool:
    return self.active_processes() &gt; 0</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self) ‑> <a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves Task object without changing its status in the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self) -&gt; &#34;Task&#34;:
    &#34;&#34;&#34;
    Retrieves Task object without changing its status in the queue
    &#34;&#34;&#34;
    cur = self.con.cursor()
    cur.execute(&#34;SELECT lock, task from tasks ORDER BY priority LIMIT 1&#34;)
    record = cur.fetchall()[0]
    oid = record[0]

    if oid is not None:
        oid = str(oid)

    task = Task.from_dict(json.loads(record[1]))
    task.oid = oid
    return task</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, task_type_include: Union[<a title="qop.enums.TaskType" href="enums.html#qop.enums.TaskType">TaskType</a>, NoneType] = None, task_type_exclude: Union[<a title="qop.enums.TaskType" href="enums.html#qop.enums.TaskType">TaskType</a>, NoneType] = None) ‑> <a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves Task object and sets status of Task in database to "in progress" (1)</p>
<p>:raises AlreadyUnderEvaluationError: If trying to pop a tasks that is already being processed
(i.e. if a race
condition occurs if the queue is processed in parallel)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, task_type_include: Optional[TaskType] = None, task_type_exclude: Optional[TaskType] = None) -&gt; &#34;Task&#34;:
    &#34;&#34;&#34;
    Retrieves Task object and sets status of Task in database to &#34;in progress&#34; (1)

    :raises AlreadyUnderEvaluationError: If trying to pop a tasks that is already being processed  (i.e. if a race
    condition occurs if the queue is processed in parallel)
    &#34;&#34;&#34;
    cur = self.con.cursor()

    assert task_type_include is None or task_type_exclude is None

    if task_type_include is not None:
        cur.execute(
            f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task LIKE &#39;__type___{int(task_type_include)}%&#39; ORDER BY priority LIMIT 1&#34;,
            (Status.PENDING,))
    elif task_type_exclude is not None:
        cur.execute(
            f&#34;SELECT _ROWID_ FROM tasks WHERE status = ? AND task NOT LIKE &#39;__type___{int(task_type_exclude)}%&#39; ORDER BY priority LIMIT 1&#34;,
            (Status.PENDING,))
    else:
        cur.execute(&#34;SELECT _ROWID_ FROM tasks WHERE status = ? ORDER BY priority LIMIT 1&#34;, (Status.PENDING,))

    oid = cur.fetchall()[0][0].__str__()

    # insert a lock UUID into the table so that we can ensure not second thread tries to execute the same
    # task
    lock = uuid.uuid4().hex
    self.set_status(oid, Status.RUNNING, lock)
    cur.execute(&#34;SELECT lock, task FROM tasks WHERE _ROWID_ = ?&#34;, (oid,))
    record = cur.fetchall()[0]
    cur.close()

    if record[0] != lock:
        raise AlreadyUnderEvaluationError

    task = Task.from_dict(json.loads(record[1]))
    lg.debug(f&#34;popped task {task}&#34;)
    task.oid = oid
    return task</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, status: Union[Tuple, int, NoneType] = None, n: int = 10) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Print an overview of the queue</p>
<p>:param n: number of tasks to fetch
:type n: int
:param status: If not None, only fetch Tasks of the given status(es)
:type status: <code>int</code>, <code>None</code> or a <code>tuple</code> of <code>int</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, status: Union[Tuple, int, None] = None, n: int = 10) -&gt; None:
    &#34;&#34;&#34;
    Print an overview of the queue

    :param n: number of tasks to fetch
    :type n: int
    :param status: If not None, only fetch Tasks of the given status(es)
    :type status: `int`, `None` or a `tuple` of `int`
    &#34;&#34;&#34;
    assert isinstance(n, int) and (n &gt; 0)
    records = self.fetch(n=n, status=status)
    for record in records:
        print(f&#34;[{record[0]}] {Task.from_dict(json.loads(record[1]))}&#34;)</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self, include_children: bool = False) ‑> <a title="qop.tasks.QueueProgress" href="#qop.tasks.QueueProgress">QueueProgress</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress(self, include_children: bool = False) -&gt; &#34;QueueProgress&#34;:
    cur = self.con.cursor()
    if include_children:
        cur.execute(&#34;SELECT status, COUNT(1) from tasks GROUP BY status&#34;)
    else:
        cur.execute(&#34;SELECT status, COUNT(1) FROM tasks WHERE parent is NULL GROUP BY status&#34;)
    res = cur.fetchall()
    cur.close()

    return QueueProgress.from_list(res)</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, task: <a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a>, priority: int = 10, parent: Union[int, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Enqueue a task</p>
<p>:param task: Task to be added to the queue
:type task: Task
:param priority: (optional) priority for executing <code>task</code> (tasks with lower priority will be executed earlier)
:type priority: int
:param parent: (optional) only for child tasks, oid/<em>ROWID</em> of the task that spawned this task
:type parent: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, task: &#34;Task&#34;, priority: int = 10, parent: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Enqueue a task

    :param task: Task to be added to the queue
    :type task: Task
    :param priority: (optional) priority for executing `task` (tasks with lower priority will be executed earlier)
    :type priority: int
    :param parent: (optional) only for child tasks, oid/_ROWID_ of the task that spawned this task
    :type parent: int
    &#34;&#34;&#34;

    lg.debug(f&#34;trying to inserted task {task.to_dict()}&#34;)
    cur = self.con.cursor()
    cur.execute(
        &#34;INSERT OR REPLACE INTO tasks (priority, task, status, parent) VALUES (?, ?, ?, ?)&#34;,
        (priority, task.to_json(), Status.PENDING, parent)
    )

    hammer_commit(self.con)
    lg.debug(f&#34;inserted task {task.to_dict()}&#34;)</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.reset_running_tasks"><code class="name flex">
<span>def <span class="ident">reset_running_tasks</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the operation with one status as another status</p>
<p>:param oid: ID of the task to mark
:type oid: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_running_tasks(self) -&gt; None:
    &#34;&#34;&#34;
    Mark the operation with one status as another status

    :param oid: ID of the task to mark
    :type oid: int
    &#34;&#34;&#34;
    lg.info(f&#34;set all running tasks to pending&#34;)
    cur = self.con.cursor()
    cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where status = ?&#34;, (int(Status.PENDING), int(Status.RUNNING)))
    hammer_commit(self.con)
    cur.close()</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, ip=None, port=None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Execute all pending tasks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, ip=None, port=None) -&gt; None:
    &#34;&#34;&#34;Execute all pending tasks&#34;&#34;&#34;

    # remove finished que runs
    self.transfer_processes = [p for p in self.transfer_processes if p.is_alive()]
    self.convert_processes = [p for p in self.convert_processes if p.is_alive()]

    if self.n_pending &lt; 1:
        lg.warning(&#34;queue is empty&#34;)
        return None

    if len(self.transfer_processes) &gt;= self.max_transfer_processes:
        lg.debug(f&#34;already running {self.max_transfer_processes} queues&#34;)

    if len(self.convert_processes) &gt;= self.max_convert_processes:
        lg.debug(f&#34;already running {self.max_convert_processes} convert queues&#34;)

    while len(self.transfer_processes) &lt; self.max_transfer_processes:
        lg.info(&#34;starting new queue runner&#34;)
        p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, None, TaskType.CONVERT))
        p.start()
        self.transfer_processes.append(p)

    while len(self.convert_processes) &lt; self.max_convert_processes:
        lg.info(&#34;starting new convert queue runner&#34;)
        p = multiprocessing.Process(target=self.__start_run_process, args=(ip, port, TaskType.CONVERT, None))
        p.start()
        self.convert_processes.append(p)</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.set_status"><code class="name flex">
<span>def <span class="ident">set_status</span></span>(<span>self, oid: int, status: <a title="qop.enums.Status" href="enums.html#qop.enums.Status">Status</a>, lock: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the operation with the <em>ROWID</em> <code>oid</code> as "pending" (0)</p>
<p>:param oid: ID of the task to mark
:type oid: int
:param status: Status see enums.Status
:type status: Status
:param lock: python object-id of the Task that executes the queued task. Must be <code>None</code> except for switching
tasks to <em>running</em>.
:type lock: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_status(self, oid: int, status: Status, lock: str = None) -&gt; None:
    &#34;&#34;&#34;
    Mark the operation with the _ROWID_ `oid` as &#34;pending&#34; (0)

    :param oid: ID of the task to mark
    :type oid: int
    :param status: Status see enums.Status
    :type status: Status
    :param lock: python object-id of the Task that executes the queued task. Must be `None` except for switching
      tasks to *running*.
    :type lock: int
    &#34;&#34;&#34;
    lg.info(f&#34;mark {oid} {status.name}&#34;)
    cur = self.con.cursor()

    if status == Status.RUNNING:
        assert lock is not None
        cur.execute(&#34;UPDATE tasks SET status = ?, lock = ? where _ROWID_ = ?&#34;, (int(status), lock, oid))
    else:
        assert lock is None
        cur.execute(&#34;UPDATE tasks SET status = ?, lock = NULL where _ROWID_ = ?&#34;, (int(status), oid))

    hammer_commit(self.con)
    cur.close()</code></pre>
</details>
</dd>
<dt id="qop.tasks.TaskQueue.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; None:
    for p in self.convert_processes + self.transfer_processes:
        p.terminate()
    self.reset_running_tasks()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qop.tasks.TaskQueueElement"><code class="flex name class">
<span>class <span class="ident">TaskQueueElement</span></span>
<span>(</span><span>task: <a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a>, priority: 1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enqueued Task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskQueueElement:
    &#34;&#34;&#34;An enqueued Task&#34;&#34;&#34;

    task = None  #: A Task
    status = None  #: Status of the queued Task
    priority = None  #: Priority of the queued Task

    def __init__(self, task: Task, priority: 1) -&gt; None:
        self.task = task
        self.priority = priority

    def __lt__(self, other) -&gt; bool:
        return self.priority &lt; other.priority

    def __gt__(self, other) -&gt; bool:
        return self.priority &gt; other.priority

    def __eq__(self, other) -&gt; bool:
        return self.__dict__ == other.__dict__

    def __ne__(self, other) -&gt; bool:
        return self.__dict__ != other.__dict__</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="qop.tasks.TaskQueueElement.priority"><code class="name">var <span class="ident">priority</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.tasks.TaskQueueElement.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="qop.tasks.TaskQueueElement.task"><code class="name">var <span class="ident">task</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="qop.tasks.UnknownTaskTypeError"><code class="flex name class">
<span>class <span class="ident">UnknownTaskTypeError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Inappropriate argument value (of correct type).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnknownTaskTypeError(ValueError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qop" href="index.html">qop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qop.tasks.hammer_commit" href="#qop.tasks.hammer_commit">hammer_commit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qop.tasks.ConvertTask" href="#qop.tasks.ConvertTask">ConvertTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.ConvertTask.color_repr" href="#qop.tasks.ConvertTask.color_repr">color_repr</a></code></li>
<li><code><a title="qop.tasks.ConvertTask.spawn" href="#qop.tasks.ConvertTask.spawn">spawn</a></code></li>
<li><code><a title="qop.tasks.ConvertTask.to_dict" href="#qop.tasks.ConvertTask.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.CopyTask" href="#qop.tasks.CopyTask">CopyTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.CopyTask.color_repr" href="#qop.tasks.CopyTask.color_repr">color_repr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.DeleteTask" href="#qop.tasks.DeleteTask">DeleteTask</a></code></h4>
</li>
<li>
<h4><code><a title="qop.tasks.EchoTask" href="#qop.tasks.EchoTask">EchoTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.EchoTask.color_repr" href="#qop.tasks.EchoTask.color_repr">color_repr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.FailTask" href="#qop.tasks.FailTask">FailTask</a></code></h4>
</li>
<li>
<h4><code><a title="qop.tasks.FileTask" href="#qop.tasks.FileTask">FileTask</a></code></h4>
</li>
<li>
<h4><code><a title="qop.tasks.MoveTask" href="#qop.tasks.MoveTask">MoveTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.MoveTask.color_repr" href="#qop.tasks.MoveTask.color_repr">color_repr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.QueueProgress" href="#qop.tasks.QueueProgress">QueueProgress</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.QueueProgress.fmt_summary" href="#qop.tasks.QueueProgress.fmt_summary">fmt_summary</a></code></li>
<li><code><a title="qop.tasks.QueueProgress.from_dict" href="#qop.tasks.QueueProgress.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.QueueProgress.from_list" href="#qop.tasks.QueueProgress.from_list">from_list</a></code></li>
<li><code><a title="qop.tasks.QueueProgress.to_dict" href="#qop.tasks.QueueProgress.to_dict">to_dict</a></code></li>
<li><code><a title="qop.tasks.QueueProgress.total" href="#qop.tasks.QueueProgress.total">total</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.SimpleConvertTask" href="#qop.tasks.SimpleConvertTask">SimpleConvertTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.SimpleConvertTask.color_repr" href="#qop.tasks.SimpleConvertTask.color_repr">color_repr</a></code></li>
<li><code><a title="qop.tasks.SimpleConvertTask.to_dict" href="#qop.tasks.SimpleConvertTask.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.SleepTask" href="#qop.tasks.SleepTask">SleepTask</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.SleepTask.color_repr" href="#qop.tasks.SleepTask.color_repr">color_repr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.Task" href="#qop.tasks.Task">Task</a></code></h4>
<ul class="two-column">
<li><code><a title="qop.tasks.Task.color_repr" href="#qop.tasks.Task.color_repr">color_repr</a></code></li>
<li><code><a title="qop.tasks.Task.from_dict" href="#qop.tasks.Task.from_dict">from_dict</a></code></li>
<li><code><a title="qop.tasks.Task.oid" href="#qop.tasks.Task.oid">oid</a></code></li>
<li><code><a title="qop.tasks.Task.parent_oid" href="#qop.tasks.Task.parent_oid">parent_oid</a></code></li>
<li><code><a title="qop.tasks.Task.run" href="#qop.tasks.Task.run">run</a></code></li>
<li><code><a title="qop.tasks.Task.to_dict" href="#qop.tasks.Task.to_dict">to_dict</a></code></li>
<li><code><a title="qop.tasks.Task.to_json" href="#qop.tasks.Task.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.TaskQueue" href="#qop.tasks.TaskQueue">TaskQueue</a></code></h4>
<ul class="two-column">
<li><code><a title="qop.tasks.TaskQueue.active_processes" href="#qop.tasks.TaskQueue.active_processes">active_processes</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.convert_processes" href="#qop.tasks.TaskQueue.convert_processes">convert_processes</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.fetch" href="#qop.tasks.TaskQueue.fetch">fetch</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.flush" href="#qop.tasks.TaskQueue.flush">flush</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.is_active" href="#qop.tasks.TaskQueue.is_active">is_active</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_fail" href="#qop.tasks.TaskQueue.n_fail">n_fail</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_ok" href="#qop.tasks.TaskQueue.n_ok">n_ok</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_pending" href="#qop.tasks.TaskQueue.n_pending">n_pending</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_running" href="#qop.tasks.TaskQueue.n_running">n_running</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_skip" href="#qop.tasks.TaskQueue.n_skip">n_skip</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.n_total" href="#qop.tasks.TaskQueue.n_total">n_total</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.peek" href="#qop.tasks.TaskQueue.peek">peek</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.pop" href="#qop.tasks.TaskQueue.pop">pop</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.print" href="#qop.tasks.TaskQueue.print">print</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.progress" href="#qop.tasks.TaskQueue.progress">progress</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.put" href="#qop.tasks.TaskQueue.put">put</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.reset_running_tasks" href="#qop.tasks.TaskQueue.reset_running_tasks">reset_running_tasks</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.run" href="#qop.tasks.TaskQueue.run">run</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.set_status" href="#qop.tasks.TaskQueue.set_status">set_status</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.stop" href="#qop.tasks.TaskQueue.stop">stop</a></code></li>
<li><code><a title="qop.tasks.TaskQueue.transfer_processes" href="#qop.tasks.TaskQueue.transfer_processes">transfer_processes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.TaskQueueElement" href="#qop.tasks.TaskQueueElement">TaskQueueElement</a></code></h4>
<ul class="">
<li><code><a title="qop.tasks.TaskQueueElement.priority" href="#qop.tasks.TaskQueueElement.priority">priority</a></code></li>
<li><code><a title="qop.tasks.TaskQueueElement.status" href="#qop.tasks.TaskQueueElement.status">status</a></code></li>
<li><code><a title="qop.tasks.TaskQueueElement.task" href="#qop.tasks.TaskQueueElement.task">task</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qop.tasks.UnknownTaskTypeError" href="#qop.tasks.UnknownTaskTypeError">UnknownTaskTypeError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>